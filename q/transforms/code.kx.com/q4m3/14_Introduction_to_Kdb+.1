



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="Q for Mortals">
      
      
        <link rel="canonical" href="14_Introduction_to_Kdb+.1">
      
      
        <meta name="author" content="Jeffry Borror">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="img/favicon.ico">
      <meta name="generator" content="mkdocs-0.17.3, mkdocs-material-2.7.2">
    
    
      
        <title>14. Introduction to Kdb+ - Q for Mortals</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/application.8d40d89b.css">
      
        <link rel="stylesheet" href="assets/stylesheets/application-palette.6079476c.css">
      
    
    
      <script src="assets/javascripts/modernizr.1aa3b519.js"></script>
    
    
      <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
      
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
      <link rel="stylesheet" href="stylesheets/extra.css">
    
      <link rel="stylesheet" href="http://code.kx.com/stylesheets/prism.css">
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="blue" data-md-color-accent="deep-orange">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <a href="14_Introduction_to_Kdb+.1#14-introduction-to-kdb" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="http://code.kx.com/q4m3" title="Q for Mortals" class="md-header-nav__button md-logo">
          
            <img src="img/qfm3.jpg" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                Q for Mortals
              </span>
              <span class="md-header-nav__topic">
                14. Introduction to Kdb+
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    <span class="md-nav__button md-logo">
      
        <img src="img/qfm3.jpg" width="48" height="48">
      
    </span>
    Q for Mortals
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="redirect/index.html" title="code.kx.com" class="md-nav__link">
      code.kx.com
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="index.html" title="Contents" class="md-nav__link">
      Contents
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="preface/index.html" title="Preface" class="md-nav__link">
      Preface
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="0_Overview/index.html" title="0. Overview" class="md-nav__link">
      0. Overview
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="1_Q_Shock_and_Awe.1" title="1. Q Shock and Awe" class="md-nav__link">
      1. Q Shock and Awe
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="2_Basic_Data_Types_Atoms/index.html" title="2. Basic Data Types – Atoms" class="md-nav__link">
      2. Basic Data Types – Atoms
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="3_Lists.1" title="3. Lists" class="md-nav__link">
      3. Lists
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="4_Operators.1" title="4. Operators" class="md-nav__link">
      4. Operators
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="5_Dictionaries.1" title="5. Dictionaries" class="md-nav__link">
      5. Dictionaries
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="6_Functions.1" title="6. Functions" class="md-nav__link">
      6. Functions
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="7_Transforming_Data/index.html" title="7. Transforming Data" class="md-nav__link">
      7. Transforming Data
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="8_Tables.1" title="8. Tables" class="md-nav__link">
      8. Tables
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="9_Queries_q-sql.1" title="9. Queries – q-sql" class="md-nav__link">
      9. Queries – q-sql
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="10_Execution_Control/index.html" title="10. Execution Control" class="md-nav__link">
      10. Execution Control
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="11_IO.1" title="11. I/O" class="md-nav__link">
      11. I/O
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="12_Workspace_Organization.1" title="12. Workspace Organization" class="md-nav__link">
      12. Workspace Organization
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="13_Commands_and_System_Variables.1" title="13. Commands and System Variables" class="md-nav__link">
      13. Commands and System Variables
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="toc">
        14. Introduction to Kdb+
      </label>
    
    <a href="14_Introduction_to_Kdb+.1" title="14. Introduction to Kdb+" class="md-nav__link md-nav__link--active">
      14. Introduction to Kdb+
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#140-overview" title="14.0 Overview" class="md-nav__link">
    14.0 Overview
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#141-tables-in-memory-and-serialization" title="14.1 Tables in Memory and Serialization" class="md-nav__link">
    14.1 Tables in Memory and Serialization
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1411-tables-and-keyed-tables" title="14.1.1 Tables and Keyed Tables" class="md-nav__link">
    14.1.1 Tables and Keyed Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1412-foreign-keys-and-link-columns" title="14.1.2 Foreign Keys and Link Columns" class="md-nav__link">
    14.1.2 Foreign Keys and Link Columns
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1413-serializing-tables" title="14.1.3 Serializing Tables" class="md-nav__link">
    14.1.3 Serializing Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1414-operating-on-serialized-tables" title="14.1.4 Operating on Serialized Tables" class="md-nav__link">
    14.1.4 Operating on Serialized Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1415-the-database-view" title="14.1.5 The Database View" class="md-nav__link">
    14.1.5 The Database View
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#142-splayed-tables" title="14.2 Splayed Tables" class="md-nav__link">
    14.2 Splayed Tables
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1420-splaying-a-table" title="14.2.0 Splaying a Table" class="md-nav__link">
    14.2.0 Splaying a Table
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1421-creating-splayed-tables" title="14.2.1 Creating Splayed Tables" class="md-nav__link">
    14.2.1 Creating Splayed Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1422-splayed-tables-with-symbol-columns" title="14.2.2 Splayed Tables with Symbol Columns" class="md-nav__link">
    14.2.2 Splayed Tables with Symbol Columns
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1423-splayed-tables-with-nested-columns" title="14.2.3 Splayed Tables with Nested Columns" class="md-nav__link">
    14.2.3 Splayed Tables with Nested Columns
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1424-basic-operations-on-splayed-tables" title="14.2.4 Basic Operations on Splayed Tables" class="md-nav__link">
    14.2.4 Basic Operations on Splayed Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1425-operations-on-a-splayed-directory" title="14.2.5 Operations on a Splayed Directory" class="md-nav__link">
    14.2.5 Operations on a Splayed Directory
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1426-appending-to-a-splayed-table" title="14.2.6 Appending to a Splayed Table" class="md-nav__link">
    14.2.6 Appending to a Splayed Table
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1427-manual-operations-on-a-splayed-directory" title="14.2.7 Manual Operations on a Splayed Directory" class="md-nav__link">
    14.2.7 Manual Operations on a Splayed Directory
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1428-working-with-sym-files" title="14.2.8 Working with sym Files" class="md-nav__link">
    14.2.8 Working with sym Files
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1429-splayed-tables-with-link-columns" title="14.2.9 Splayed Tables with Link Columns" class="md-nav__link">
    14.2.9 Splayed Tables with Link Columns
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14210-query-execution-on-splayed-tables" title="14.2.10 Query Execution on Splayed Tables" class="md-nav__link">
    14.2.10 Query Execution on Splayed Tables
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#143-partitioned-tables" title="14.3 Partitioned Tables" class="md-nav__link">
    14.3 Partitioned Tables
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1431-partitions" title="14.3.1 Partitions" class="md-nav__link">
    14.3.1 Partitions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1432-partition-domain" title="14.3.2 Partition Domain" class="md-nav__link">
    14.3.2 Partition Domain
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1433-creating-partitioned-tables" title="14.3.3 Creating Partitioned Tables" class="md-nav__link">
    14.3.3 Creating Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1434-working-with-partitioned-tables" title="14.3.4 Working with Partitioned Tables" class="md-nav__link">
    14.3.4 Working with Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1435-the-virtual-column-i-in-partitioned-tables" title="14.3.5 The Virtual Column i in Partitioned Tables" class="md-nav__link">
    14.3.5 The Virtual Column i in Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1436-query-execution-on-partitioned-tables" title="14.3.6 Query Execution on Partitioned Tables" class="md-nav__link">
    14.3.6 Query Execution on Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1437-map-reduce" title="14.3.7 Map-Reduce" class="md-nav__link">
    14.3.7 Map-Reduce
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1438-multiple-partitioned-tables" title="14.3.8 Multiple Partitioned Tables" class="md-nav__link">
    14.3.8 Multiple Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1439-examples-of-other-partition-domain-types" title="14.3.9 Examples of Other Partition Domain Types" class="md-nav__link">
    14.3.9 Examples of Other Partition Domain Types
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14310-partitioned-tables-with-links" title="14.3.10 Partitioned Tables with Links" class="md-nav__link">
    14.3.10 Partitioned Tables with Links
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#144-segmented-tables" title="14.4 Segmented Tables" class="md-nav__link">
    14.4 Segmented Tables
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1441-segments" title="14.4.1 Segments" class="md-nav__link">
    14.4.1 Segments
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1442-segmentation-vs-partitions" title="14.4.2 Segmentation vs. Partitions" class="md-nav__link">
    14.4.2 Segmentation vs. Partitions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1443-creating-segmented-tables" title="14.4.3 Creating Segmented Tables" class="md-nav__link">
    14.4.3 Creating Segmented Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1444-multiple-segmented-tables" title="14.4.4 Multiple Segmented Tables" class="md-nav__link">
    14.4.4 Multiple Segmented Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1445-query-execution-against-segmented-tables" title="14.4.5 Query Execution against Segmented Tables" class="md-nav__link">
    14.4.5 Query Execution against Segmented Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1446-balancing-slaves-and-cores" title="14.4.6 Balancing Slaves and Cores" class="md-nav__link">
    14.4.6 Balancing Slaves and Cores
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1447-sample-performance-data" title="14.4.7 Sample Performance Data" class="md-nav__link">
    14.4.7 Sample Performance Data
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#145-utilities-for-splaying-and-partitioning" title="14.5 Utilities for Splaying and Partitioning" class="md-nav__link">
    14.5 Utilities for Splaying and Partitioning
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1451-qqp" title="14.5.1 .Q.qp" class="md-nav__link">
    14.5.1 .Q.qp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1452-qen" title="14.5.2 .Q.en" class="md-nav__link">
    14.5.2 .Q.en
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1453-qpv" title="14.5.3 .Q.pv" class="md-nav__link">
    14.5.3 .Q.pv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1454-qind" title="14.5.4 .Q.ind" class="md-nav__link">
    14.5.4 .Q.ind
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1455-qdpft" title="14.5.5 .Q.dpft" class="md-nav__link">
    14.5.5 .Q.dpft
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1456-qfs" title="14.5.6 .Q.fs" class="md-nav__link">
    14.5.6 .Q.fs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1457-qchk" title="14.5.7 .Q.chk" class="md-nav__link">
    14.5.7 .Q.chk
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1458-qview" title="14.5.8 .Q.view" class="md-nav__link">
    14.5.8 .Q.view
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#146-kdb-database" title="14.6 Kdb Database" class="md-nav__link">
    14.6 Kdb Database
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1461-comparing-kdb-to-an-rdbms" title="14.6.1 Comparing kdb+ to an RDBMS" class="md-nav__link">
    14.6.1 Comparing kdb+ to an RDBMS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1462-the-physical-layout-of-a-kdb-database" title="14.6.2 The Physical Layout of a kdb+ Database" class="md-nav__link">
    14.6.2 The Physical Layout of a kdb+ Database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14621-the-sym-file" title="14.6.2.1 The sym File" class="md-nav__link">
    14.6.2.1 The sym File
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14622-other-serialized-files-in-root" title="14.6.2.2 Other Serialized Files in Root" class="md-nav__link">
    14.6.2.2 Other Serialized Files in Root
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14623-scripts" title="14.6.2.3 Scripts" class="md-nav__link">
    14.6.2.3 Scripts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14624-splayed-tables" title="14.6.2.4 Splayed Tables" class="md-nav__link">
    14.6.2.4 Splayed Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14625-partitioned-tables" title="14.6.2.5 Partitioned Tables" class="md-nav__link">
    14.6.2.5 Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14626-segmented-tables" title="14.6.2.6 Segmented Tables" class="md-nav__link">
    14.6.2.6 Segmented Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1463-creating-and-populating-a-kdb-database" title="14.6.3 Creating and Populating a kdb+ Database" class="md-nav__link">
    14.6.3 Creating and Populating a kdb+ Database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14631-what-happens-at-startup" title="14.6.3.1 What Happens at Startup?" class="md-nav__link">
    14.6.3.1 What Happens at Startup?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14632-serialized-q-entities" title="14.6.3.2 Serialized q Entities" class="md-nav__link">
    14.6.3.2 Serialized q Entities
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14633-splayed-tables" title="14.6.3.3 Splayed Tables" class="md-nav__link">
    14.6.3.3 Splayed Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14634-partitioned-tables" title="14.6.3.4 Partitioned Tables" class="md-nav__link">
    14.6.3.4 Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14635-segmented-tables" title="14.6.3.5 Segmented Tables" class="md-nav__link">
    14.6.3.5 Segmented Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14636-scripts" title="14.6.3.6 Scripts" class="md-nav__link">
    14.6.3.6 Scripts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#147-putting-it-all-together" title="14.7 Putting It All Together" class="md-nav__link">
    14.7 Putting It All Together
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1471-partitioned-database" title="14.7.1 Partitioned Database" class="md-nav__link">
    14.7.1 Partitioned Database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1472-segmented-database" title="14.7.2 Segmented Database" class="md-nav__link">
    14.7.2 Segmented Database
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#148-theres-no-place-like-qhome" title="14.8 There's No Place Like QHOME" class="md-nav__link">
    14.8 There's No Place Like QHOME
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1481-the-environment-variables" title="14.8.1 The Environment Variables" class="md-nav__link">
    14.8.1 The Environment Variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1482-q-in-da-hood" title="14.8.2 q in da hood" class="md-nav__link">
    14.8.2 q in da hood
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="A_Built-in_Functions.1" title="Appendix A. Built-in Functions" class="md-nav__link">
      Appendix A. Built-in Functions
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="B_Error_Messages/index.html" title="Appendix B. Error Messages" class="md-nav__link">
      Appendix B. Error Messages
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="colophon/index.html" title="Colophon" class="md-nav__link">
      Colophon
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#140-overview" title="14.0 Overview" class="md-nav__link">
    14.0 Overview
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#141-tables-in-memory-and-serialization" title="14.1 Tables in Memory and Serialization" class="md-nav__link">
    14.1 Tables in Memory and Serialization
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1411-tables-and-keyed-tables" title="14.1.1 Tables and Keyed Tables" class="md-nav__link">
    14.1.1 Tables and Keyed Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1412-foreign-keys-and-link-columns" title="14.1.2 Foreign Keys and Link Columns" class="md-nav__link">
    14.1.2 Foreign Keys and Link Columns
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1413-serializing-tables" title="14.1.3 Serializing Tables" class="md-nav__link">
    14.1.3 Serializing Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1414-operating-on-serialized-tables" title="14.1.4 Operating on Serialized Tables" class="md-nav__link">
    14.1.4 Operating on Serialized Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1415-the-database-view" title="14.1.5 The Database View" class="md-nav__link">
    14.1.5 The Database View
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#142-splayed-tables" title="14.2 Splayed Tables" class="md-nav__link">
    14.2 Splayed Tables
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1420-splaying-a-table" title="14.2.0 Splaying a Table" class="md-nav__link">
    14.2.0 Splaying a Table
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1421-creating-splayed-tables" title="14.2.1 Creating Splayed Tables" class="md-nav__link">
    14.2.1 Creating Splayed Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1422-splayed-tables-with-symbol-columns" title="14.2.2 Splayed Tables with Symbol Columns" class="md-nav__link">
    14.2.2 Splayed Tables with Symbol Columns
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1423-splayed-tables-with-nested-columns" title="14.2.3 Splayed Tables with Nested Columns" class="md-nav__link">
    14.2.3 Splayed Tables with Nested Columns
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1424-basic-operations-on-splayed-tables" title="14.2.4 Basic Operations on Splayed Tables" class="md-nav__link">
    14.2.4 Basic Operations on Splayed Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1425-operations-on-a-splayed-directory" title="14.2.5 Operations on a Splayed Directory" class="md-nav__link">
    14.2.5 Operations on a Splayed Directory
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1426-appending-to-a-splayed-table" title="14.2.6 Appending to a Splayed Table" class="md-nav__link">
    14.2.6 Appending to a Splayed Table
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1427-manual-operations-on-a-splayed-directory" title="14.2.7 Manual Operations on a Splayed Directory" class="md-nav__link">
    14.2.7 Manual Operations on a Splayed Directory
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1428-working-with-sym-files" title="14.2.8 Working with sym Files" class="md-nav__link">
    14.2.8 Working with sym Files
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1429-splayed-tables-with-link-columns" title="14.2.9 Splayed Tables with Link Columns" class="md-nav__link">
    14.2.9 Splayed Tables with Link Columns
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14210-query-execution-on-splayed-tables" title="14.2.10 Query Execution on Splayed Tables" class="md-nav__link">
    14.2.10 Query Execution on Splayed Tables
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#143-partitioned-tables" title="14.3 Partitioned Tables" class="md-nav__link">
    14.3 Partitioned Tables
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1431-partitions" title="14.3.1 Partitions" class="md-nav__link">
    14.3.1 Partitions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1432-partition-domain" title="14.3.2 Partition Domain" class="md-nav__link">
    14.3.2 Partition Domain
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1433-creating-partitioned-tables" title="14.3.3 Creating Partitioned Tables" class="md-nav__link">
    14.3.3 Creating Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1434-working-with-partitioned-tables" title="14.3.4 Working with Partitioned Tables" class="md-nav__link">
    14.3.4 Working with Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1435-the-virtual-column-i-in-partitioned-tables" title="14.3.5 The Virtual Column i in Partitioned Tables" class="md-nav__link">
    14.3.5 The Virtual Column i in Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1436-query-execution-on-partitioned-tables" title="14.3.6 Query Execution on Partitioned Tables" class="md-nav__link">
    14.3.6 Query Execution on Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1437-map-reduce" title="14.3.7 Map-Reduce" class="md-nav__link">
    14.3.7 Map-Reduce
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1438-multiple-partitioned-tables" title="14.3.8 Multiple Partitioned Tables" class="md-nav__link">
    14.3.8 Multiple Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1439-examples-of-other-partition-domain-types" title="14.3.9 Examples of Other Partition Domain Types" class="md-nav__link">
    14.3.9 Examples of Other Partition Domain Types
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14310-partitioned-tables-with-links" title="14.3.10 Partitioned Tables with Links" class="md-nav__link">
    14.3.10 Partitioned Tables with Links
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#144-segmented-tables" title="14.4 Segmented Tables" class="md-nav__link">
    14.4 Segmented Tables
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1441-segments" title="14.4.1 Segments" class="md-nav__link">
    14.4.1 Segments
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1442-segmentation-vs-partitions" title="14.4.2 Segmentation vs. Partitions" class="md-nav__link">
    14.4.2 Segmentation vs. Partitions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1443-creating-segmented-tables" title="14.4.3 Creating Segmented Tables" class="md-nav__link">
    14.4.3 Creating Segmented Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1444-multiple-segmented-tables" title="14.4.4 Multiple Segmented Tables" class="md-nav__link">
    14.4.4 Multiple Segmented Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1445-query-execution-against-segmented-tables" title="14.4.5 Query Execution against Segmented Tables" class="md-nav__link">
    14.4.5 Query Execution against Segmented Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1446-balancing-slaves-and-cores" title="14.4.6 Balancing Slaves and Cores" class="md-nav__link">
    14.4.6 Balancing Slaves and Cores
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1447-sample-performance-data" title="14.4.7 Sample Performance Data" class="md-nav__link">
    14.4.7 Sample Performance Data
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#145-utilities-for-splaying-and-partitioning" title="14.5 Utilities for Splaying and Partitioning" class="md-nav__link">
    14.5 Utilities for Splaying and Partitioning
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1451-qqp" title="14.5.1 .Q.qp" class="md-nav__link">
    14.5.1 .Q.qp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1452-qen" title="14.5.2 .Q.en" class="md-nav__link">
    14.5.2 .Q.en
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1453-qpv" title="14.5.3 .Q.pv" class="md-nav__link">
    14.5.3 .Q.pv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1454-qind" title="14.5.4 .Q.ind" class="md-nav__link">
    14.5.4 .Q.ind
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1455-qdpft" title="14.5.5 .Q.dpft" class="md-nav__link">
    14.5.5 .Q.dpft
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1456-qfs" title="14.5.6 .Q.fs" class="md-nav__link">
    14.5.6 .Q.fs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1457-qchk" title="14.5.7 .Q.chk" class="md-nav__link">
    14.5.7 .Q.chk
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1458-qview" title="14.5.8 .Q.view" class="md-nav__link">
    14.5.8 .Q.view
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#146-kdb-database" title="14.6 Kdb Database" class="md-nav__link">
    14.6 Kdb Database
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1461-comparing-kdb-to-an-rdbms" title="14.6.1 Comparing kdb+ to an RDBMS" class="md-nav__link">
    14.6.1 Comparing kdb+ to an RDBMS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1462-the-physical-layout-of-a-kdb-database" title="14.6.2 The Physical Layout of a kdb+ Database" class="md-nav__link">
    14.6.2 The Physical Layout of a kdb+ Database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14621-the-sym-file" title="14.6.2.1 The sym File" class="md-nav__link">
    14.6.2.1 The sym File
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14622-other-serialized-files-in-root" title="14.6.2.2 Other Serialized Files in Root" class="md-nav__link">
    14.6.2.2 Other Serialized Files in Root
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14623-scripts" title="14.6.2.3 Scripts" class="md-nav__link">
    14.6.2.3 Scripts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14624-splayed-tables" title="14.6.2.4 Splayed Tables" class="md-nav__link">
    14.6.2.4 Splayed Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14625-partitioned-tables" title="14.6.2.5 Partitioned Tables" class="md-nav__link">
    14.6.2.5 Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14626-segmented-tables" title="14.6.2.6 Segmented Tables" class="md-nav__link">
    14.6.2.6 Segmented Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1463-creating-and-populating-a-kdb-database" title="14.6.3 Creating and Populating a kdb+ Database" class="md-nav__link">
    14.6.3 Creating and Populating a kdb+ Database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14631-what-happens-at-startup" title="14.6.3.1 What Happens at Startup?" class="md-nav__link">
    14.6.3.1 What Happens at Startup?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14632-serialized-q-entities" title="14.6.3.2 Serialized q Entities" class="md-nav__link">
    14.6.3.2 Serialized q Entities
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14633-splayed-tables" title="14.6.3.3 Splayed Tables" class="md-nav__link">
    14.6.3.3 Splayed Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14634-partitioned-tables" title="14.6.3.4 Partitioned Tables" class="md-nav__link">
    14.6.3.4 Partitioned Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14635-segmented-tables" title="14.6.3.5 Segmented Tables" class="md-nav__link">
    14.6.3.5 Segmented Tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#14636-scripts" title="14.6.3.6 Scripts" class="md-nav__link">
    14.6.3.6 Scripts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#147-putting-it-all-together" title="14.7 Putting It All Together" class="md-nav__link">
    14.7 Putting It All Together
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1471-partitioned-database" title="14.7.1 Partitioned Database" class="md-nav__link">
    14.7.1 Partitioned Database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1472-segmented-database" title="14.7.2 Segmented Database" class="md-nav__link">
    14.7.2 Segmented Database
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#148-theres-no-place-like-qhome" title="14.8 There's No Place Like QHOME" class="md-nav__link">
    14.8 There's No Place Like QHOME
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1481-the-environment-variables" title="14.8.1 The Environment Variables" class="md-nav__link">
    14.8.1 The Environment Variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="14_Introduction_to_Kdb+.1#1482-q-in-da-hood" title="14.8.2 q in da hood" class="md-nav__link">
    14.8.2 q in da hood
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="14-introduction-to-kdb">14. Introduction to Kdb+<a class="headerlink" href="14_Introduction_to_Kdb+.1#14-introduction-to-kdb" title="Permanent link">&para;</a></h1>
<h2 id="140-overview">14.0 Overview<a class="headerlink" href="14_Introduction_to_Kdb+.1#140-overview" title="Permanent link">&para;</a></h2>
<p>In this chapter we provide an introduction to kdb+, which is the database offering from Kx. Roughly speaking, kdb+ is what happens when q tables are persisted and then mapped back into memory for operations. Of course, things are more complicated than that.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Many examples in this chapter use directories that are parented directly to the root. This is done for pedagogical reasons and also to make paths short enough to fit on a page without wrapping. Unless you are creating kdb+ databases on a machine over which you have complete control, you will <strong>not</strong> be able to create directories in the root. When emulating the examples here, you should change the paths to relative paths that live under a directory that you control. You can usually do this by removing the leading <code>/</code> in the path.</p>
</div>
<h2 id="141-tables-in-memory-and-serialization">14.1 Tables in Memory and Serialization<a class="headerlink" href="14_Introduction_to_Kdb+.1#141-tables-in-memory-and-serialization" title="Permanent link">&para;</a></h2>
<p>It is possible to maintain a table entirely in memory, provided you have enough physical memory to hold it. There is one problem with this from a database perspective:</p>
<ul>
<li>An in-memory table is ephemeral – meaning that all modifications are lost if the q process dies.</li>
</ul>
<p>One solution is to serialize the table to persistent storage using <code>set</code> or similar mechanisms. In this section we recapitulate material from previous chapters from this perspective.</p>
<h3 id="1411-tables-and-keyed-tables">14.1.1 Tables and Keyed Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1411-tables-and-keyed-tables" title="Permanent link">&para;</a></h3>
<p>A table is the <code>flip</code> of a column dictionary, in which address slots are reversed but no data is moved during the transpose. For example, here is a table with two simple list columns.</p>
<pre><code class="q">q)flip `s`v!(`a`b`c;100 200 300)
_
</code></pre>

<p>Table definition syntax permits tables to be defined in more readable format.</p>
<pre><code class="q">q)([] s:`a`b`c; v:100 200 300)
_
</code></pre>

<p>The schema of a table has the same form but with empty columns – i.e., no rows.</p>
<pre><code class="q">q)([] s:`symbol$(); v:`int$())
_
q)t:([] s:`a`b; v:10 20)
_
</code></pre>

<p>It is good practice to prototype the empty lists in a schema; unfortunately, this is not possible if the corresponding columns are not simple lists.</p>
<p>The type of any table is <code>98h</code> and the function <code>meta</code> summarizes the column names, types and attributes in a result keyed table.</p>
<pre><code class="q">q)meta ([] s:`symbol$(); v:`int$())
_
</code></pre>

<p>A keyed table is a dictionary that establishes positional correspondence between a table of (presumably unique) keys and a table of values.</p>
<pre><code class="q">q)([] id:1001 1002 1003)!([] s:`a`b`c; v:100 200 300)
id | s v
----| -----
1001| a 100
1002| b 200
1003| c 300
</code></pre>

<p>Table definition syntax is more compact.</p>
<pre><code class="q">q)([id:1001 1002 1003] s:`a`b`c; v:100 200 300)
_
</code></pre>

<p>The type of any keyed table is <code>99h</code>, since it is a dictionary and <code>meta</code> applies exactly as with tables.</p>
<h3 id="1412-foreign-keys-and-link-columns">14.1.2 Foreign Keys and Link Columns<a class="headerlink" href="14_Introduction_to_Kdb+.1#1412-foreign-keys-and-link-columns" title="Permanent link">&para;</a></h3>
<p>A foreign key is one or more table columns that are enumerated over the key component of a keyed table. For example, the column ID in the table below is a foreign key over <code>kt</code>. Note that the foreign-key column is identified by the name of its target table in the result of <code>meta</code>.</p>
<pre><code class="q">q)kt:([id:1001 1002 1003] s:`a`b`c; v:100 200 300)
q)t:([]; id:`kt$1002 1001 1003 1001; q:100 101 102 103)
q)meta t
c | t f a
--| ------
id| j kt
q | j
</code></pre>

<p>A query on a table having a foreign key can access columns in the keyed table via dot notation.</p>
<pre><code class="q">q)select id.v, q from t
v q
-------
200 100
100 101
300 102
100 103
</code></pre>

<p>A link column is similar to a foreign key, in that its entries are indices of rows in a table, but you must perform the lookup manually. The advantages of link columns are:</p>
<ul>
<li>The target can be a table or keyed table.</li>
<li>The target can be the table containing the link column.</li>
<li>Link columns can be splayed or partitioned, whereas foreign keys cannot.</li>
</ul>
<p>Here is the previous foreign-key example redone with a link column against a table.</p>
<pre><code class="q">q)tk:([] id:1001 1002 100; s:`a`b`c; v:100 200 300)
q)t:([]; id:`tk!(exec id from tk)?1002 1001 1003 1001; q:100 101 102 103)
q)meta t
c | t f a
--| ------
id| i tk
q | j
</code></pre>

<div class="admonition important">
<p class="admonition-title">Important</p>
<p>As of this writing (Sep 2015) integers are 64-bit in q3+, enumerations are 32-bit. In particular, the integers stored in a link column are truncated to 32 bits by the <code>!</code> operator. Observe that type of the link column ID in the previous example is <code>I</code> even though the result of the <code>?</code> operation is of type <code>j</code>. One consequence is that you cannot use links columns with tables of more than 2<sup>32</sup> records.</p>
</div>
<p>Here is an example that uses a link column to implement a hierarchical structure in a table. The column <code>pid</code> is a link column that relates a row to its parent row.</p>
<pre><code class="q">q)tree:([] id:0 1 2 3 4; pid:`tree!0N 0 0 1 1; v:100 200 300 400 500)
q)select from tree where pid=0 / find children of root
_
</code></pre>

<h3 id="1413-serializing-tables">14.1.3 Serializing Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1413-serializing-tables" title="Permanent link">&para;</a></h3>
<p>It is possible to persist any table (or keyed table) using the general q serialization/deserialization capability of <code>set</code> and <code>get</code>. There is no restriction on table or column types.</p>
<pre><code class="q">q)`:/data/t set ([] s:`a`b`c; v:100 200 300)
`:/data/t
q)\\
&gt;q
q)t:get `:/data/t
q)t
_
</code></pre>

<p>You can serialize foreign keys and link columns and bring them back into memory.</p>
<pre><code class="q">q)kt:([id:1001 1002 1003] s:`a`b`c; v:100 200 300)
q)tk:([] id:1001 1002 100; s:`a`b`c; v:100 200 300)
q)`:/data/kt set kt
`:/data/kt
q)`:/data/tk set tk
`:/data/tk
q)`:/data/t1 set ([]; id:`kt$1002 1001 1003 1001; q:100 101 102 103)
`:/data/t1
q)`:/data/t2 set ([]; id:`kt!(exec id from tk)?1002 1001 1003 1001; q:100 101 102 103)
`:/data/t2
q)\\
&gt;q
q)kt:get `:/data/kt
q)tk:get `:/data/tk
q)t1:get `:/data/t1
q)t2:get `:/data/t2
</code></pre>

<h3 id="1414-operating-on-serialized-tables">14.1.4 Operating on Serialized Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1414-operating-on-serialized-tables" title="Permanent link">&para;</a></h3>
<p>You operate on a serialized table by loading it into memory with <code>get</code> or <code>\l</code>.</p>
<pre><code class="q">q)`:/data/t set ([] s:`a`b`c; v:100 200 300)
`:/data/t
q)\l /data/t
`t
q)select from t
_
q)t1: get `:/data/t
q)select from t1
_
</code></pre>

<p>Alternatively, you can perform a query on a serialized table by specifying its file handle as the table name.</p>
<pre><code class="q">q)`:/data/t set ([] s:`a`b`c; v:100 200 300)
`:/data/t
q)select from `:/data/t where s in `a`c
s v
-----
a 100
c 300
q)`:/data/t upsert (`x;42)
`:/data/t
q).[`:/data/t;();,;([] s:`y`z; v:400 500)]
`:/data/t
q)select from `:/data/t where s in `x`y`z
_
</code></pre>

<p>Similar operations are available on keyed tables.</p>
<pre><code class="q">q)`:/data/kt set ([k:`a`b`c] v:10 20 30)
`:/data/kt
q)`:/data/kt upsert (`b;200)
`:/data/kt
q)`:/data/kt upsert (`x;42)
`:/data/kt
q)select from `:/data/kt
k| v
-| ---
a| 10
b| 200
c| 30
x| 42
</code></pre>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The limitation to using a serialized table or keyed table is that, behind the scenes, the operations load it into memory and write it back out. Amongst other things, this means that anyone wanting to work with it must be able to fit it into memory in its entirety.</p>
</div>
<h3 id="1415-the-database-view">14.1.5 The Database View<a class="headerlink" href="14_Introduction_to_Kdb+.1#1415-the-database-view" title="Permanent link">&para;</a></h3>
<p>Persisting a table via serialization creates a single file in the OS file system. Let’s raise our perspective to the 50,000-foot level. From this height, we see the table as a single point.</p>
<p><strong>Big Picture (0):</strong> We think of a serialized table as a zero-dimensional persisted form since it is stored in a single file and is not decomposed.</p>
<table>
<thead>
<tr>
<th></th>
<th>file</th>
</tr>
</thead>
<tbody>
<tr>
<td>table</td>
<td>▪</td>
</tr>
</tbody>
</table>
<p>Here the ▪ represents the contents of the table as an opaque entity. This contrasts with higher-dimensional forms we shall encounter later.</p>
<h2 id="142-splayed-tables">14.2 Splayed Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#142-splayed-tables" title="Permanent link">&para;</a></h2>
<p>In the previous section, we saw that it is possible to persist tables using serialization. From a database perspective there are (at least) two issues with operating on serialized tables due to the fact that the entire table is loaded into memory.</p>
<ul>
<li>The entire table must fit into memory on each user’s machine.</li>
<li>Operations against the persisted table will be slow due to reloading the entire table each time.</li>
</ul>
<h3 id="1420-splaying-a-table">14.2.0 Splaying a Table<a class="headerlink" href="14_Introduction_to_Kdb+.1#1420-splaying-a-table" title="Permanent link">&para;</a></h3>
<p>When a table is too large to fit into memory as a single entity, we can persist its components into a directory. This is called <em>splaying</em> the table because the table is pulled apart into its constituent columns (it is an interesting exercise to look up the derivation of this word in English). Splaying solves the memory/reload issue because a splayed table is mapped into memory; columns are loaded on demand then memory is released when no longer needed. Tables with many columns especially benefit from splaying since most queries refer to only a handful of columns and only those columns will actually be loaded.</p>
<p>A splayed table corresponds to a directory whose name <strong>is</strong> the table name. Each column list of the table is serialized into a file whose name <strong>is</strong> the column name.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You don’t have any choice in the names.</p>
</div>
<p>A list of the symbolic column names is serialized to the hidden file <code>.d</code>in the directory to record column order. This is the <strong>only</strong> metadata stored by kdb+; all other metadata is read from directory and file names.</p>
<p>Customarily the splayed directory is created one level down from a directory that serves as the root of the database.</p>
<pre><code class="q">/root
/tablename &lt;- splayed table directory
.d &lt;- file with column names
column1name &lt;- column data file
column2name &lt;- column data file
…
</code></pre>

<p>From the 50,000-foot level, we see the following on the file system.</p>
<p><strong>Big Picture (1):</strong> We think of a splayed table as a persisted form that is cut vertically along columns.</p>
<table>
<thead>
<tr>
<th></th>
<th>column1</th>
<th>column2</th>
<th>column3</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>table</td>
<td>▪</td>
<td>▪</td>
<td>▪</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>Geometrically, the persisted table is 1-dimensional – there is a point for each column in the persisted image of the table.</p>
<h3 id="1421-creating-splayed-tables">14.2.1 Creating Splayed Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1421-creating-splayed-tables" title="Permanent link">&para;</a></h3>
<p>We start with a very simple example of creating a splayed table. Make sure you include the trailing <code>/</code> in the file handle; otherwise, you will serialize the table into a single file.</p>
<pre><code class="q">q)`:/db/t/ set ([] v1:10 20 30; v2:1.1 2.2 3.3)
`:/data/t/
q)\ls -a /db/t
,&quot;.&quot;
&quot;..&quot;
&quot;.d&quot;
&quot;v1&quot;
&quot;v2&quot;
</code></pre>

<p>It is also possible to create a splayed table with <code>upsert</code>, or with the equivalent generalized application, using the file handle as the table name. When the file does not exist, these act like <code>set</code>.</p>
<pre><code class="q">q)`:/db/t2/ upsert ([] v1:10 20 30; v2:1.1 2.2 3.3)
_
q).[`:/db/t3/; (); ,; ([] v1:10 20 30; v2:1.1 2.2 3.3)]
_
</code></pre>

<p>Reading the constituents of the splayed directory with <code>get</code> demonstrates that they are simply serialized q entities.</p>
<pre><code class="q">q)get `:/db/t/v1
10 20 30
q)get `:/db/t/v2
_
q)get `:/db/t/.d
`v1`v2
</code></pre>

<p>Of course, if your notion of fashion is a hair shirt, you can splay your table manually. In a fresh <code>/db</code> directory,</p>
<pre><code class="q">q)t:([] v1:10 20 30; v2:1.1 2.2 3.3)
q)cs:cols t
q){[cname] (hsym `$&quot;/db/&quot;,string cname) set t cname} each cs
_
q)`:/db/.d set cs
_
</code></pre>

<p>There are serious restrictions on what can be splayed.</p>
<ol>
<li>
<p>Tables can be splayed. Keyed tables <strong>cannot</strong>.</p>
<p>This might seem to preclude relational capabilities since it eliminates persisting a foreign key relation. But the day is saved by link columns, which can be persisted. See <a href="14_Introduction_to_Kdb+.1#1412-foreign-keys-and-link-columns">§14.1.2</a>.</p>
</li>
<li>
<p>Only columns that are simple lists or compound lists can be splayed. By <em>compound</em> list we mean a list of simple lists of uniform type.</p>
<p>The isn’t too limiting in practice since data often comes in a uniform format that can be readily put into simple or compound lists. Incidentally, the reason for this restriction is that working with mapped general lists would be much slower than working with simple or compound lists, especially for very large data sets. See <a href="14_Introduction_to_Kdb+.1#1424-basic-operations-on-splayed-tables">§14.2.4</a> for more on nested columns.</p>
</li>
<li>
<p>All symbol columns must be enumerated.</p>
<p>This restriction might seem to complicate life but there are conventions and utilities that eliminate most of the pain. See <a href="14_Introduction_to_Kdb+.1#1422-splayed-tables-with-symbol-columns">§14.2.2</a>. </p>
</li>
</ol>
<h3 id="1422-splayed-tables-with-symbol-columns">14.2.2 Splayed Tables with Symbol Columns<a class="headerlink" href="14_Introduction_to_Kdb+.1#1422-splayed-tables-with-symbol-columns" title="Permanent link">&para;</a></h3>
<p>The convention for symbol columns in splayed (and partitioned) tables is that <strong>all</strong> symbol columns in <strong>all</strong> tables are enumerated over the list sym, which is serialized into the root directory.</p>
<p>The author prefers to use a projected form of the utility <code>.Q.en</code> for enumerating symbols. Its first parameter is the file handle of the root directory (the location of the sym file) and its second parameter is the table whose symbol columns you wish enumerated. Here is a simple example.</p>
<pre><code class="q">q)`:/db/t/ set .Q.en[`:/db;] ([] s1:`a`b`c; v:10 20 30; s2:`x`y`z)
`:/db/t/
q)\ls /db
&quot;sym&quot;
,&quot;t&quot;
q}\\
&gt;q
q)\l /db
q)sym
`a`b`c`x`y`z
q)select from t
_
</code></pre>

<p>We offer several observations on the action of <code>.Q.en</code> in this example.</p>
<ul>
<li>If there is a sym list in memory, it is overwritten</li>
<li>If there is a sym list on disk it is locked and then loaded into memory</li>
<li>If no sym list exists in memory or on disk an empty one is created.</li>
<li>All symbols in all symbol columns of the table are conditionally enumerated over the sym list in memory.</li>
<li>Once the enumeration is complete the sym list in memory is serialized to the root and the file is unlocked.</li>
</ul>
<p>Once again, you could don your hair shirt and do symbol enumeration manually.</p>
<pre><code class="q">q)t:([] s1:`a`b`c; v:10 20 30; s2:`x`y`z)
q)sym:()
q)`:/db/t/ set @[t;exec c from meta t where &quot;s&quot;=t;`sym?]
_
q)sym
_
\\
&gt;q
q)\l /db
q)select from t
_
</code></pre>

<h3 id="1423-splayed-tables-with-nested-columns">14.2.3 Splayed Tables with Nested Columns<a class="headerlink" href="14_Introduction_to_Kdb+.1#1423-splayed-tables-with-nested-columns" title="Permanent link">&para;</a></h3>
<p>The only nested columns that can be splayed are what we call <em>compound</em> lists – i.e., lists of simple lists of uniform type. The most common example is a list of strings, which is a list of lists of char. A compound column is indicated by an upper case letter in the result of <code>meta</code>. For example, here is a table having two compound columns, which can be splayed in a fresh directory <code>/db</code>.</p>
<pre><code class="q">q)meta ([] ci:(1 2 3; enlist 4; 5 6); cstr:(&quot;abc&quot;;enlist&quot;d&quot;;&quot;ef&quot;))
c   | t f a
----| -----
x   | J
cstr| C
q)`:/db/tcomp2/ set ([] ci:(1 2 3; enlist 4; 5 6); cstr:(&quot;abc&quot;;enlist&quot;d&quot;;&quot;ef&quot;))
_
</code></pre>

<p>By contrast, the following table cannot be splayed and results in an error.</p>
<pre><code class="q">q)meta ([] c:(1;1,1;`1))
c| t f a
-| -----
c|
q)`:/db/tcomp2/ set ([] c:(1;1,1;`1))
k){$[@x;.[x;();:;y];-19!((,y),x)]}
'type
q.q))
</code></pre>

<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You might reasonably think that you can use the result of <code>meta</code> to determine whether your table can be splayed by checking for a blank in the <code>t</code> column. You would be wrong since <code>meta</code> only examines the initial item of a column list and improperly reports some mixed columns as compound.</p>
</div>
<pre><code class="q">q)meta ([] c:(1 2 3 ;1,1;`1))
c| t f a
-| -----
c| J
q)`:/db/tbad/ set ([] c:(1 2 3 ;1,1;`1))
k){$[@x;.[x;();:;y];-19!((,y),x)]}
'type
q.q))
</code></pre>

<p>The following function will tell you which columns of a table cannot be splayed.</p>
<pre><code class="q">{where {(ts~1#0h)|1&lt;count ts:distinct `type each`x} each flip x}
</code></pre>

<p>When you splay a table with compound columns, q creates not one but two files for each compound column. For example, in a fresh directory <code>/db</code>, we splay a table with a single string column and then inspect the splayed directory.</p>
<pre><code class="q">q)`:/db/tstr/ set ([] c:(&quot;abc&quot;;enlist &quot;d&quot;;&quot;ef&quot;))
_
q)system &quot;ls -a /db/tstr&quot;
,&quot;.&quot;
&quot;..&quot;
&quot;.d&quot;
,&quot;c&quot;
&quot;c#&quot;
</code></pre>

<p>Observe that there are two files associated with the compound column  – namely, <code>c</code> and <code>c#</code>. If you examine these files you will discover that the “sharp” file contains the binary data of the original list in flattened form and the non-sharp file is a serialized q list of integers representing the lengths of each sublist of the original list.</p>
<pre><code class="q">q)&quot;c&quot;$read1 hsym `$&quot;/db/tstr/c#&quot;
&quot;abcdef&quot;
q)read1 hsym `$&quot;/db/tstr/c&quot;
0xfe205700000000000300000000000000030000000000000004000000000000000600000000000000
</code></pre>

<p>Interestingly, <code>get</code> reconstitutes the list from the non-sharp file.</p>
<pre><code class="q">q)get hsym `$&quot;/db/tstr/c&quot;
&quot;abc&quot;
,&quot;d&quot;
&quot;ef&quot;
</code></pre>

<p>The purpose of writing compound columns as two files is to speed up operations against them when the splayed table is mapped into memory. Of course, the processing won’t be as fast as for a simple column, but it is still plenty fast for most purposes.</p>
<p>One question that always arises when designing a kdb+ database is whether to store text data as symbols or strings. The advantage of symbols is that they have atomic semantics and, since they are integers under the covers once they are enumerated, processing is quite fast. The main issue with symbols is that if you make all text into symbols, your sym list gets enormous and the advantages of enumeration disappear.</p>
<p>In contrast, strings do not pollute the sym list with one-off instances and are reasonably fast. The disadvantage is that they are not first class and you must revert to teenage years by using <code>like</code> to match them.</p>
<div class="admonition recommendation">
<p class="admonition-title">Recommendation</p>
<p>Only make text columns into symbols when the fields will be drawn from a small, reasonably stable domain and there is significant repetition in their use. When in doubt, start with a string column. It is much easier to convert a string column to symbols that it is to remove symbols from the sym list.</p>
</div>
<p>A text column that is drawn from a fixed list or a lookup table is an ideal candidate. So are invariant keys, provided the key domain is small and will not grow unreasonably. On the other hand, fields such as comments or notes should always be strings.</p>
<h3 id="1424-basic-operations-on-splayed-tables">14.2.4 Basic Operations on Splayed Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1424-basic-operations-on-splayed-tables" title="Permanent link">&para;</a></h3>
<p>Let us create a splayed table in a fresh <code>/db</code>.</p>
<pre><code class="q">q)`:/db/t/ set .Q.en[`:/db;] ([] s1:`a`b`c; v:10 20 30; s2:`x`y`z)
_
</code></pre>

<p>To operate on a splayed table you can map it into memory in one of two ways.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Note the lack of a trailing <code>/</code> in both techniques of mapping the table below.</p>
</div>
<p>You can specify a splayed table on the q startup command immediately after the q executable.</p>
<pre><code class="bash">$q /db/t
</code></pre>

<pre><code class="q">q)select from t
_
</code></pre>

<p>Alternatively, you can use <code>\l</code> to map the table.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Confusingly, folks say they are “loading” the table, even though none of the table data is actually brought into memory in this step.</p>
</div>
<pre><code class="q">q)\l /db/t
`t
q)select from t
_
</code></pre>

<p>The illusion that the table is actually in memory after it is mapped is convincing. Many fundamental table operations work on splayed tables.</p>
<pre><code class="q">q)\a
,`t
q)meta t
c | t f a
--| -----
s1| s
v | j
s2| s
q)cols t
`s1`v`s2
q)type t
98h
q)count t
3
</code></pre>

<p>You can index records.</p>
<pre><code class="q">q)t[0]
s1| `sym$`a
v | 10
s2| `sym$`x
</code></pre>

<p>You <strong>cannot</strong> use dot notation to extract columns from a splayed table but you <strong>can</strong> extract a column with symbol indexing.</p>
<pre><code class="q">q)t.s1
'type
q)t `s1
`sym$`a`b`c
</code></pre>

<p>You can use both <code>select</code> and <code>exec</code> templates on a splayed table.</p>
<pre><code class="q">q)select v from t where s1=`c
_
q)exec s1 from t
_
</code></pre>

<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>This contrasts with partitioned tables where you can only use <code>select</code>.</p>
</div>
<h3 id="1425-operations-on-a-splayed-directory">14.2.5 Operations on a Splayed Directory<a class="headerlink" href="14_Introduction_to_Kdb+.1#1425-operations-on-a-splayed-directory" title="Permanent link">&para;</a></h3>
<p>As of this writing (Sep 2015), the table operations available against the file handle of a splayed table are:<code>select</code>, <code>exec</code>, <code>upsert</code>, <code>xasc</code>, <code>`<em>attr</em>#</code> (apply an attribute).</p>
<p>With <code>t</code> splayed as above,</p>
<pre><code class="q">q)select from `:/db/t
_
q)exec v from `:/db/t
_
q)`v xdesc `:/db/t
_
q)@[`:/db/t;`s1;`p#]
_
q)\l /db
q)meta t
_
</code></pre>

<p>We point out a source of confusion to qbies. Specifically, the behavior of <code>update</code> on a splayed table that has been mapped into memory. Starting with a fresh directory <code>/db</code>, create a splayed table, map it into memory and then update it.</p>
<pre><code class="q">q)`:/db/t/ set .Q.en[`:/db;] ([] s1:`a`b`c; v:10 20 30; s2:`x`y`z)
_
q)\l /db
q)update v:300 from `t where s1=`c
`t
q)select from t
s1 v s2
---------
a 10 x
b 20 y
c 300 z
</code></pre>

<p>But a rude surprise awaits when we remap the table.</p>
<pre><code class="q">q)\l /db
q)select from t
s1 v  s2
--------
a  10 x
b  20 y
c  30 z
</code></pre>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Updates applied to a mapped table are only visible in the workspace and are not reflected on disk. There may be scenarios where this is useful but we advise avoiding it.</p>
</div>
<p>And now we arrive at a fundamental limitation of kdb+.</p>
<div class="admonition important">
<p class="admonition-title">Really Important</p>
<p>It is not possible to use built-in operations to update data in persisted splayed tables.</p>
</div>
<p>You read that correctly. Kdb+ is intended to store data that is not updated or deleted once it has been written. We shall see in the next section how to append to a splayed table, which makes it possible to process updates and deletes in a bitemporal fashion, but this capability is not available out of the box.</p>
<h3 id="1426-appending-to-a-splayed-table">14.2.6 Appending to a Splayed Table<a class="headerlink" href="14_Introduction_to_Kdb+.1#1426-appending-to-a-splayed-table" title="Permanent link">&para;</a></h3>
<p>Since <code>upsert</code> acts as <code>insert</code> on regular (non-keyed) tables and only non-keyed tables can be splayed, we use <code>upsert</code> with the splayed directory name in order to append records to a splayed table on disk. This is a good thing, since <code>insert</code> doesn’t work on splayed tables. Also, because symbol columns must be enumerated for splayed tables, it is best to make rows into tables.</p>
<p>In a fresh <code>/db</code>,</p>
<pre><code class="q">q)`:/db/t/ set .Q.en[`:/db;] ([] s1:`a`b`c; v:10 20 30; s2:`x`y`z)
_
q)`:/db/t/ upsert .Q.en[`:/db;] ([] s1:`d`e; v:40 50; s2:`u`v)
_
q)`:/db/t upsert .Q.en[`:/db;] enlist `s1`v`s2!(`f;60;`t)
_
q)`:/db/t upsert .Q.en[`:/db;] flip `s1`v`s2!flip ((`g;70;`r);(`h;80;`s))
_
q)\l / db
q)select from t
_
</code></pre>

<p>You can use <code>upsert</code> in this fashion to build large splayed tables incrementally. The following example can be enhanced to create a splayed table step-by-step as batches of new records arrive. In a fresh <code>/db</code>,</p>
<pre><code class="q">q)batch:{[rt;tn;recs] hsym[`$rt,&quot;/&quot;,tn,&quot;/&quot;] upsert .Q.en[hsym `$rt;] recs}
q)dayrecs:{([] dt:x; ti:asc 100?24:00:00; sym:100?`ibm`aapl; qty:100*1+100?1000)}
q)appday:batch[&quot;/db&quot;;&quot;t&quot;;]
q)appday dayrecs 2015.01.01
_
q)appday dayrecs 2015.01.02
_
q)appday dayrecs 2015.01.03
_
q)\l /db
q)select from t
_
</code></pre>

<h3 id="1427-manual-operations-on-a-splayed-directory">14.2.7 Manual Operations on a Splayed Directory<a class="headerlink" href="14_Introduction_to_Kdb+.1#1427-manual-operations-on-a-splayed-directory" title="Permanent link">&para;</a></h3>
<p>Although there are no built-in operations to update splayed tables on disk, you can perform such operations by manipulating the serialized files.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The examples shown here should be used with caution, as none of the operations are atomic; they are simply file-system manipulation. Even read-only users could see inconsistent data, so things are best done when no other users are accessing the database.</p>
</div>
<p>Here is an example of how to simulate an <code>update .. where</code> on a single column. In a fresh <code>/db</code>,</p>
<pre><code class="q">q)`:/db/t/ set ([] ti:09:30:00 09:31:00; p:101.5 33.5)
_
q)`:/db/t/p set .[get `:/db/t/p; where 09:31:00=get `:/db/t/ti; :;42.0]
_
q)\l /db/t
_
q)select from t
_
</code></pre>

<p>To add a new column of nulls to an existing splayed table, we first get the row count from any column file. Then we revise the <code>.d</code> file with the new column name. This example is easily modified to place arbitrary data in the new column.</p>
<pre><code class="q">q)`:/db/t/s set (count get `:/db/t/ti)#`
_
q)`:/db/t/.d set get[`:/db/t/.d] union `s
_
</code></pre>

<p>To delete a column, remove its file and revise the <code>.d</code> file to reflect its absence.</p>
<pre><code class="q">q)system &quot;rm /db/t/s&quot;
q)`:/db/t/.d set get[`:/db/t/.d] except `s
_
q)\l /db
q)select from t
_
</code></pre>

<p>While you can sort a splayed table on disk, suppose you want to implement your own custom sort. We show how to create the standard sort. First create the appropriate sort index with <code>iasc</code> or <code>idesc</code> and then use this to re-index all the column files. Here we perform a descending sort by the <code>ti</code> column.</p>
<pre><code class="q">q)cs:system &quot;ls /db/t&quot;
q)I:idesc `:/db/t/ti
q){pth set get[pth:hsym `$&quot;/db/t/&quot;,x] I} each cs
`:/db/t/ix`:/db/t/p`:/db/t/ti
q)\l /db
q)select from t
_
</code></pre>

<h3 id="1428-working-with-sym-files">14.2.8 Working with sym Files<a class="headerlink" href="14_Introduction_to_Kdb+.1#1428-working-with-sym-files" title="Permanent link">&para;</a></h3>
<p>On occasion you may need to perform operations involving the sym files. For example, you may want to move a table from one database to another. Or you may find that your sym domain has become polluted due to symbol columns that should have been strings. Or you may have unwisely chosen to have many different enumeration domains and you wish to consolidate them into one. All these situations can be resolved by careful operations on the sym file(s).</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Updating sym files is delicate and should be done with great care, only after you have made a complete backup of the root directory. Corrupting the sym file will almost certainly render your database useless.</p>
</div>
<p>In our first example we show how to merge a table from one database into another. Suppose we have root directories <code>/db1</code> and <code>/db2</code>, both with the standard sym file in the root and with splayed tables <code>t1</code> and <code>t2</code>, respectively. In fresh directories <code>/db1</code> and <code>/db2</code>,</p>
<pre><code class="q">q)`:/db1/t1/ set .Q.en[`:/db1;] ([] s:`a`b`c; v:10 20 30)
_
q)`:/db2/t2/ set .Q.en[`:/db2;] ([] s:`c`d`e; v:300 400 500)
_
q)get `:/db1/sym
`a`b`c
q)get `:/db2/sym
`c`d`e
</code></pre>

<p>In order to copy table <code>t2</code> to the <code>/db1</code> root, we un-enumerate all its symbol columns and then re-enumerate them in the target database.</p>
<pre><code class="q">q)symcols2:exec c from meta `:/db2/t2 where t=&quot;s&quot;
q)t2noenum:@[select from `:/db2/t2;symcols2;value]
q)`:/db1/t2/ set .Q.en[`:/db1] t2noenum
_
q)get `:/db1/sym
`a`b`c`d`e
</code></pre>

<p>In another example, suppose that we mistakenly made a comment column into symbols instead of strings, with the result being a pollution of the sym domain with many single-use items. In a fresh <code>/db</code>, we save <code>t1</code> with a valid symbol column and then screw up on the comment field in <code>t2</code>.</p>
<pre><code class="q">q)`:/db/t1/ set .Q.en[`:/db;] ([] s:`a`b`c; v:10 20 30)
_
q)`:/db/t2/ set .Q.en[`:/db;] ([] c:1 2 3; comment:`$(&quot;abc&quot;;&quot;de&quot;;&quot;fg&quot;))
_
q)get `:/db/sym
`a`b`c`abc`de`fg
</code></pre>

<p>First we load the database and remove the offending comments from the sym list.</p>
<pre><code class="q">q)\l /db
q)sym:sym except exec comment from t2
q)sym
_
</code></pre>

<p>Next we re-enumerate the re-typed culprit table over the clean sym list and re-splay it. Note that we use (<code>`sym?</code>) for the enumeration since it is possible that some of the comments actually overlapped with symbols from other tables.</p>
<pre><code class="q">q)reenum:{@[x;exec c from meta x where t=&quot;s&quot;;`sym?]}
q)`:/db/t2/ set reenum ([] s:`a`b`c; comment:(&quot;abc&quot;;&quot;de&quot;;&quot;fg&quot;))
</code></pre>

<p>Next we un-enumerate, re-enumerate and re-splay the remaining tables.</p>
<pre><code class="q">q)ts:system[&quot;a&quot;] except `t2
q)unenum:{@[select from x; exec c from meta x where t=&quot;s&quot;;value]}
q){(hsym `$&quot;/db/&quot;,string[x],&quot;/&quot;) set reenum unenum x} each ts
_
</code></pre>

<p>Finally we overwrite the sym file with the correct sym list that is now in memory and reload the database to check our handiwork.</p>
<pre><code class="q">q)`:/db/sym set sym
q)\l /db
q)meta t1
_
q)meta t2
_
</code></pre>

<h3 id="1429-splayed-tables-with-link-columns">14.2.9 Splayed Tables with Link Columns<a class="headerlink" href="14_Introduction_to_Kdb+.1#1429-splayed-tables-with-link-columns" title="Permanent link">&para;</a></h3>
<p>We previously pointed out that you cannot splay a keyed table, and therefore cannot have a foreign-key relation between splayed tables. However, you can splay a link column and then use dot notation just as you would with a foreign key. You must do the work of creating the index yourself, just as with link columns with tables in memory.</p>
<p>In our first example, we create the link at the same time as we splay the tables. This is the same as creating the link on in-memory tables and then splaying them. In a fresh <code>/db</code>,</p>
<pre><code class="q">q)t1:([] c1:`c`b`a; c2: 10 20 30)
q)t2:([] c3:`a`b`a`c; c4: 1. 2. 3. 4.)
q)update t1lnk:`t1!t1[`c1]?t2[`c3] from `t2
_
q)`:/db/t1/ set `.Q.en[`:/db;] t1
_
q)`:/db/t2/ set `.Q.en[`:/db;] t2
_
q)\\
$q
q)\l /db
q)meta t2
c | t f a
-----| ------
c3 | s
c4 | f
t1lnk| i t1
q)select c3,t1lnk.c2,c4 from t2
_
</code></pre>

<p>Now we redo this example, assuming that the tables have already been splayed. You could map the database into memory but let’s work directly with the files. We have the additional step of appending the link columns to the <code>.d</code> file for <code>t2</code>.</p>
<pre><code class="q">q)`:/db/t1/ set .Q.en[`:/db;] ([] c1:`c`b`a; c2: 10 20 30)
_
q)`:/db/t2/ set .Q.en[`:/db;] ([] c3:`a`b`a`c; c4: 1. 2. 3. 4.)
_
q)`:/db/t2/t1link set `t1!(get `:/db/t1/c1)?get `:/db/t2/c3
_
q).[`:/db/t2/.d;();,;`t1link]
_
q)\l /db
q)meta t2
_
</code></pre>

<h3 id="14210-query-execution-on-splayed-tables">14.2.10 Query Execution on Splayed Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#14210-query-execution-on-splayed-tables" title="Permanent link">&para;</a></h3>
<p>As we noted in the introduction of the chapter, splayed tables are a memory win, in that the table is mapped into memory and columns are actually loaded only as needed. Since a typical query requires only a handful of columns, this can greatly reduce the amount of memory required to process a table with many columns.</p>
<p>In addition to the memory win, if the same columns are referenced again soon, there is a good chance that their data is cached, either in memory or by the storage controller. This can be a significant performance win.</p>
<p>There is also a more subtle performance win in how the where phrase is implemented. As mentioned in Chapter 11, each where subphrase produces a boolean vector that acts as mask, on which positions will be examined in the subsequent grouping and aggregation. When the table is mapped, this can also significantly reduce the amount of data that is loaded into memory.</p>
<h2 id="143-partitioned-tables">14.3 Partitioned Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#143-partitioned-tables" title="Permanent link">&para;</a></h2>
<p>To recap the previous section, a splayed table has been split vertically along its columns and is subsequently mapped into memory. When a query is executed against the mapped table, column data is loaded as needed and is presumably cached for subsequent access. This reduces the table’s memory footprint, especially for tables with many columns.</p>
<p>Some timeseries data is so large that even the individual columns may not fit into memory – for example, daily trades and quotes for an entire exchange. In this case, we can further decompose the table by slicing horizontally – called <em>partitioning</em> in kdb+. For example, the solution for trades and quotes is to slice into daily portions. The result is a collection of daily splayed directories, one for each day for which data exists.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>All partitioned tables are splayed but not all splayed tables are partitioned.</p>
</div>
<h3 id="1431-partitions">14.3.1 Partitions<a class="headerlink" href="14_Introduction_to_Kdb+.1#1431-partitions" title="Permanent link">&para;</a></h3>
<p>A <em>partitioned</em> table is a splayed table that is further decomposed by grouping records having common values along a column of special type. The allowable special column types have the property that the underlying value is an integer: date, month, year and long.</p>
<p>The slice of records having a given value is splayed into a directory, called a <em>partition</em>, whose name <strong>is</strong> that common value. In the canonical finance example, historical trades (or quotes) are stored in daily partition directories – remember a q date is an integer under the covers.</p>
<p><strong>Big Picture (2)</strong>: We think of a partitioned table as a two-dimensional persisted form since it is cut in two directions: vertically by splaying along columns and horizontally by slicing into partitions.</p>
<table>
<thead>
<tr>
<th></th>
<th>column1</th>
<th>column2</th>
<th>column3</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>partition1</td>
<td>▪</td>
<td>▪</td>
<td>▪</td>
<td>…</td>
</tr>
<tr>
<td>partition2</td>
<td>▪</td>
<td>▪</td>
<td>▪</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>Here each ▪ represents a (partial) column of a partition slice as an opaque entity.</p>
<p>As with splaying, kdb+ implements partitioning using the OS directory structure. Each partition must be stored in a directory immediately under the database root directory. The directory name <strong>is</strong> the common column value for all the rows in the partition. Each partition directory in turn contains a subdirectory holding a splayed table with the records for that slice. The two-dimensional decomposition is reflected in two levels of nested directories under the root.</p>
<p>Since each splayed table subdirectory name <strong>is</strong> the name of the table, these names must be consistent across all partitions. Likewise, as portions of a single table, all splayed slices should have identical schemas. This means that each slice directory contains column files with the same names and internal data types, as well as identical .d files.</p>
<pre><code>/root
    /partitionvalue1
        /tablename
            .d
            column1name
            column2name
            …
    /partitionvalue2
        /tablename
            .d
            column1name
            column2name
            …
        …
</code></pre>

<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Since a partition directory name factors out the common value for all records in its slice, do not include the partition column when you splay a partition slice – e.g., do not include a date column for a daily partitioned table. Instead, kdb+ infers the name, value and type from the partition directory name and creates a virtual column from this information. The name of the virtual column is set by q and cannot be controlled.</p>
</div>
<h3 id="1432-partition-domain">14.3.2 Partition Domain<a class="headerlink" href="14_Introduction_to_Kdb+.1#1432-partition-domain" title="Permanent link">&para;</a></h3>
<p>We call the type of the virtual column for the partition the <em>partition domain</em>. As noted previously, the partition domain must have an underlying integral value.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You cannot use a symbol column as a partition domain, even if the symbols are enumerated.</p>
</div>
<p>For example, suppose we have daily timeseries data. A daily partitioning could look as follows.</p>
<p>2015.01.01, 2015.01.02, …</p>
<p>The virtual column is date in this case. Under each partition directory, there is a subdirectory <code>t</code> with that day’s slice of records.</p>
<pre><code>/db
    /2015.01.01
        /t          &lt;- trade records for 2015.01.01
    /2015.01.02
        /t          &lt;- trade records for 2015.01.02 …
</code></pre>

<div class="admonition important">
<p class="admonition-title">Important</p>
<p>A kdb+ database can only have a single partition domain. This means that you must create separate databases if you need partitions of different granularity. For example, you cannot have daily and monthly partitions in one database.</p>
</div>
<p>There is no requirement that there be entries for every value in the partition domain. For example, there may be no trades for holidays.</p>
<pre><code>/db
    /2014.12.31
        /t
    /2015.01.02
        /t
    …
</code></pre>

<p>If we partition by month,</p>
<p>2015.01m, 2015.02m, …</p>
<p>the virtual column name is <code>month</code>.</p>
<p>For daily data that requires frequent multi-year queries, partitioning by year may be better.</p>
<p>2010, 2011, …</p>
<p>In this case, the virtual column is <code>year</code> even though there is no year type in q. The values are recognized as valid q years if they are less than 10,000.</p>
<p>You can also partition by an arbitrary int such as a bin number.</p>
<p>0, 1, …</p>
<p>This results in a virtual column <code>int</code>.</p>
<h3 id="1433-creating-partitioned-tables">14.3.3 Creating Partitioned Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1433-creating-partitioned-tables" title="Permanent link">&para;</a></h3>
<p>For simplicity, our first example has no symbols. In a fresh <code>/db</code>,</p>
<pre><code class="q">q)`:/db/2015.01.01/t/ set ([] ti:09:30:00 09:31:00; p:101 102f)
_
q)`:/db/2015.01.02/t/ set ([] ti:09:30:00 09:31:00; p:101.5 102.5)
_
q)\l /db
q)t / never do this at home!
date ti p
-------------------------
2015.01.01 09:30:00 101
2015.01.01 09:31:00 102
2015.01.02 09:30:00 101.5
2015.01.02 09:31:00 102.5
</code></pre>

<p>The table appears to be in the workspace, along with the virtual date columns, but this is an illusion. It is actually mapped into memory. The request to display <code>t</code> forces all columns for all days to be loaded into memory.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Always qualify the partition column in the first where sub-phrase in any query against a partitioned table. If you do not, you will cause all partitions to be loaded into memory and will probably live-lock the server. Well before this completes, your colleagues will be at your desk with pitchforks and burning torches.</p>
</div>
<p>A more responsible way to create the previous display is,</p>
<pre><code class="q">q)select from t where date within 2015.01.01 2015.01.02
_
</code></pre>

<p>Here we partition tables with symbols in a fresh <code>/db</code>. <!-- Note that we wrap the line in our display. --></p>
<pre><code class="q">q)`:/db/2015.01.01/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; s:`ibm`msft; p:101 33f)
_
q)`:/db/2015.01.02/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; s:`ibm`msft; p:101.5 33.5)
_
q)\l /db
q)select from t where date within 2015.01.01 2015.01.02
_
</code></pre>

<h3 id="1434-working-with-partitioned-tables">14.3.4 Working with Partitioned Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1434-working-with-partitioned-tables" title="Permanent link">&para;</a></h3>
<p>Continuing with the last example of the previous section, we can apply some basic operations on a partitioned table that has been mapped. Observe that the virtual partition column is included in the results of <code>meta</code> and <code>cols</code>.</p>
<pre><code class="q">q)count t
_
q)meta t
c   | t f a
----| -----
date| d
ti  | v
s   | s
p   | f
q)cols t
`date`ti`s`p
q)type t
98h
</code></pre>

<p>However, none of the following work on partitioned tables, even though they work on splayed tables.</p>
<pre><code class="q">t[0j]
t[;`p]
0#t
exec from t
select[1] from t
`p xasc t
</code></pre>

<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The fact that <code>exec</code> doesn’t work on partitioned tables is annoying but the workaround is,
<code>q
exec … from select … from …</code></p>
</div>
<p>The select template, or the equivalent functional form, is <strong>the</strong> way to access data for a partitioned table. We have already seen how to retrieve the records for consecutive days. Here is the query to retrieve a day’s slice.</p>
<pre><code class="q">q)select from t where date=2015.01.01
_
</code></pre>

<p>Here is how to retrieve the first or last day without hardcoding the date.</p>
<pre><code class="q">q)select from t where date=first date
_
q)select from t where date=max date
_
</code></pre>

<p>Always place the partition column constraint first.</p>
<pre><code class="q">q)select from t where date=2015.01.01, ti&lt;09:30:30
_
</code></pre>

<p>You can group by the partition column. Note we have wrapped the line for display.</p>
<pre><code class="q">q)select hi:max p, lo:min p by date from t
where date within 2015.01.01 2015.01.02
_
</code></pre>

<h3 id="1435-the-virtual-column-i-in-partitioned-tables">14.3.5 The Virtual Column i in Partitioned Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1435-the-virtual-column-i-in-partitioned-tables" title="Permanent link">&para;</a></h3>
<p>In a partitioned table, the virtual column i does <strong>not</strong> refer to absolute row number as it does with in-memory and splayed tables. Instead, it refers to the relative row number within a partition. Thus, a constraint on i alone would apply across all partitions and the result will contain that row in each partition slice – probably not what you want and almost certainly a bad idea (colleagues with pitchforks again).</p>
<p>Continuing with the previous example, the following query retrieves the initial record from each of the specified partitions.</p>
<pre><code class="q">q)select from t where date in 2015.01.01 2015.01.02, i=0
_
</code></pre>

<p>The following queries retrieve the first and last records in the table, respectively.</p>
<pre><code class="q">q) select from t where date=first date, i=0
_
q) select from t where date=max date, i=max i
_
</code></pre>

<p>See <a href="14_Introduction_to_Kdb+.1#1446-balancing-slaves-and-cores">§14.4.6</a> for using <code>.Q.ind</code> to index <strong>across</strong> partitions.</p>
<h3 id="1436-query-execution-on-partitioned-tables">14.3.6 Query Execution on Partitioned Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1436-query-execution-on-partitioned-tables" title="Permanent link">&para;</a></h3>
<p>Query execution against a partitioned table is more complex than execution against a splayed table. Understanding how it works is necessary to achieve good design and performance with kdb+ databases.</p>
<p>Recall that the motivation for partitions was to avoid loading entire columns into memory. Behind the scenes, kdb+ achieves this as follows.</p>
<ul>
<li>Analyze the where phrase to determine which partition slices are targeted by the query</li>
<li>Process the remaining where sub-phrases to determine the column sub-domains that must be loaded.</li>
<li>Process the query separately against the requisite partition slices to obtain partial results.</li>
<li>Combine the partial results to obtain the final result.</li>
</ul>
<p>Reading only partial column slices of a table having many partitions is clearly a big memory and performance win. But things are even more interesting with regard to the third point above. If you have started q without slaves, the query is executed sequentially against the partitions and the time to complete is (roughly) the sum of the time against each of the partition slices.</p>
<p>By contrast, if you have started q with slaves, the query will be executed concurrently, once slice per slave. Thus, you can see significant speedup provided the query is compute-bound and the slaves are running on separate cores. On the other hand, if the query is I/O bound and you have only a single I/O channel to the data, you may see no speedup.</p>
<p>Next we discuss how kdb+ executes some types of queries concurrently.</p>
<h3 id="1437-map-reduce">14.3.7 Map-Reduce<a class="headerlink" href="14_Introduction_to_Kdb+.1#1437-map-reduce" title="Permanent link">&para;</a></h3>
<p>We start with a brief introduction to map-reduce. Suppose we want to compute some aggregation – say the sum or the average – of a large list of numbers and have at our disposal a crop of interns armed with smartphones. Our strategy is to decompose the overall task into two stages. In the first stage, we split the list into roughly (but not exactly) equal size sublists, distributing one to each intern along with instructions on what to compute. In the second step, we collect the (partial) results from each intern and combine them to get the overall result. This is what good managers do, after all.</p>
<p>Think about how to do this for sum before continuing. For the sum, you could instruct each intern to compute the sum of her list and then compute the sum of the individual sums. The same simple approach works for count or maximum.</p>
<p>For average, things aren't quite so simple. If you simply have each intern compute an average of her list, you will need to weight each partial average by the size of the sublist to get the final average. Thus you need the count too. You quickly realize that you can distribute the average computation more effectively. Instead of asking each intern to return the average and count for her list, ask her to compute the sum and the count. In the reduction step, you obtain the overall average as the sum of the partial sums divided by the sum of the partial counts.</p>
<p>More generally, map-reduce decomposes an operation on a (presumably large) list into two suboperations, <em>op<sub>map</sub></em> and <em>op<sub>reduce</sub></em>. In the first step, called 'map', <em>op<sub>map</sub></em> is performed on each sublist to obtain a list of partial results. In the second step, called "reduce", the partial result lists are combined with <em>op<sub>reduce</sub></em> to obtain the final result. A good exercise (and interview question) is to express sorting a list using map-reduce. In greater generality, map-reduce may apply the two steps recursively – i.e., the reduce step may itself involve a map-reduce, etc.</p>
<p>It is easy to see how map-reduce applies to a query against a partitioned table, since the table is a list of records sliced into sub-lists by the partitioning. The challenge is to decompose the query into a map step and a reduce step. The solution depends on whether the query involves aggregation.</p>
<p>If there is no aggregation, the result of the query on each partition is simply the computed columns for the list of the records in the partition slice matching the constraint. In other words, produce a partial result table by computing the columns of the query across partitions. Because all the partial result tables conform, union the partial result tables in order of their virtual partition column values. In summary: fan the query across the partitions and union the ordered results.</p>
<p>Things are more interesting when the query contains aggregation. For aggregates that kdb+ recognizes as map-reducible, it applies the map operation across partition slices to obtain partial results. It then applies the reduce operation across the partial result tables to obtain the final result table.</p>
<p>At the time of this writing (Sep 2015), the aggregates that kdb+ can decompose with map-reduce are: <code>avg</code>, <code>cor</code>, <code>count</code>, <code>cov</code>, <code>dev</code>, <code>distinct</code>, <code>first</code>, <code>last</code>, <code>max</code>, <code>med</code>, <code>min</code>, <code>prd</code>, <code>sum</code>, <code>var</code>, <code>wavg</code>, <code>wsum</code>.</p>
<p>To make this more concrete, we re-examine computing an average against a daily partitioned trades table.</p>
<pre><code class="q">select avg size from trade where date within …
</code></pre>

<p>Because kdb+ recognizes <code>avg</code> as an aggregate it can decompose with map-reduce, it performs the calculation in two steps. Specifically, <em>op<sub>map</sub></em> computes the sum and record count for each date, while <em>op<sub>reduce</sub></em> divides the sum of the daily sums by the sum of the daily counts to give the average. The user gets the expected result and is none the wiser unless q was started with slaves, in which case the result maybe faster than linear.</p>
<h3 id="1438-multiple-partitioned-tables">14.3.8 Multiple Partitioned Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1438-multiple-partitioned-tables" title="Permanent link">&para;</a></h3>
<p>Recall that there can be only one partition domain in a given kdb+ root – i.e., daily, monthly, yearly or long. However, multiple tables can share this partitioning.</p>
<p>For example, quotes and trades can coexist in a daily partition. That layout would look something like,</p>
<pre><code>/db
    /2015.01.01
        /trade
        /quote
    /2015.01.02
        /trade
        /quote
</code></pre>

<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Although not all potential partition values need be populated, any value that is populated must contain slices for all tables.
The following layout is in error.
<pre><code>
/db
    /2015.01.01 &lt;- this is a bad partition!
        /quote
    /2015.01.02
        /trade
        /quote
</code></pre></p>
</div>
<p>We demonstrate how to create a simplified database with tables standing for trades and quotes in a fresh <code>/db</code> directory. Notice that we wrap the lines that do not fit within this page margin.</p>
<pre><code class="q">q)`:/db/2015.01.01/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; sym:`ibm`msft;p:101 33f)
_
q)`:/db/2015.01.02/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; sym:`ibm`msft;p:101.5 33.5)
_
q)`:/db/2015.01.01/q/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; sym:`ibm`msft;b:100.75 32.75; a:101.25 33.25f)
_
q)`:/db/2015.01.02/q/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:30:00; sym:`ibm`msft;b:101.25 33.25; a:101.75 33.75)
_
</code></pre>

<p>Mapping the root, we now find both are available.</p>
<pre><code class="q">q)select from t where date within 2015.01.01 2015.01.02
_
q)select from q where date within 2015.01.01 2015.01.02
_
</code></pre>

<p>Next we add a historical slice for q on 2014.12.31 but neglect to add the corresponding slice for t. Things seem fine when we map the root and query q on the newly added date.</p>
<pre><code class="q">q)`:/db/2014.12.31/q/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; sym:`ibm`msft; b:101. 33.; a:101.5 33.5f)
`:/db/2014.12.31/q/
q)\l /db
q)select from q where date=2014.12.31
_
</code></pre>

<p>But we get a nasty surprise when we query <code>t</code> on the missing date.</p>
<pre><code class="q">q)select from t where date=2014.12.31
k){0!(?).@[x;0;p1[;y;z]]}
'./2014.12.31/t/ti: No such file or directory
.
?
(+`ti`sym`p!`:./2014.12.31/t;();0b;())
q.Q))
</code></pre>

<p>We could remedy this by splaying an empty copy of <code>t</code> on that date. Instead we use the utility <code>.Q.chk</code> that fills all missing slices with empty tables from the most recent partition. We remap and find things are fine.</p>
<pre><code class="q">q).Q.chk `:/db
_
q)\l /db
q)select from t where date=2014.12.31
_
</code></pre>

<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you neglect to place a table slice in the most recent partition, the table will effectively disappear from your database since kdb+ inspects only that partition to determine which tables are present.</p>
</div>
<p>Continuing with our previous (repaired) example we add a trade slice for 2015.01.03 but neglect to add a quotes slice. When we remap, the table <code>q</code> is nowhere to be found.</p>
<pre><code class="q">q)`:/db/2015.01.03/t/ set .Queen[`:/db;]
 ([] ti:09:30:00 09:31:00; sym:`ibm`msft;p:101 33f)
_
q)\l /db
q)\a
,`t
</code></pre>

<p>Here is one way to fill an empty slice.</p>
<pre><code class="q">q)`:/db/2015.01.03/q/ set 0#select from `:/db/2015.01.02/q
_
q)\l /db
q)\a
`q`t
</code></pre>

<h3 id="1439-examples-of-other-partition-domain-types">14.3.9 Examples of Other Partition Domain Types<a class="headerlink" href="14_Introduction_to_Kdb+.1#1439-examples-of-other-partition-domain-types" title="Permanent link">&para;</a></h3>
<p>We present simple examples of partitions with the other permissible types. For simplicity, we do not include symbol columns; to do so, merely add the call to <code>.Q.en</code> as in previous examples.</p>
<p>Yearly partitioning can be a good solution when you regularly need to retrieve multiple years of daily data. Note that we explicitly include the date column but not the year column, which is virtual. In a fresh <code>/db</code>,</p>
<pre><code class="q">q)`:/db/2015/t/ set ([] date:2015.01.01 2015.01.02; p:101 102f)
`:/db/2015/t/
q)`:/db/2014/t/ set ([] date:2014.01.01 2014.01.02; p:101.5 102.5)
`:/db/2014/t/
q)\l /db
q)select from t where year within 2014 2015
_
</code></pre>

<p>Monthly partitioning can be a good compromise between daily and yearly when you have both single day and year-to-date queries. We explicitly include the date column but not the month column, which is virtual.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Do <strong>not</strong> include a trailing <code>/</code> in the partition directory name but <strong>do</strong> include it in the queries.</p>
</div>
<p>In a fresh <code>/db</code>,</p>
<pre><code class="q">q)`:/db/2015.01/t/ set ([] date:2015.01.01 2015.01.02; p:101 102f)
`:/db/2015.01/t/
q)`:/db/2015.02/t/ set ([] date:2015.02.01 2015.02.02; p:101.5 102.5)
`:/db/2015.02/t/
q)\l /db
q)select from t where month within 2015.01m 2015.02m
_
</code></pre>

<p>You can partition by a long to slice into arbitrary bins. The data need not be daily. In a fresh <code>/db</code>,</p>
<pre><code class="q">q)`:/db/1/t/ set ([] ti:09:30:00 09:31:00; p:101 102f)
_
q)`:/db/2/t/ set ([] ti:09:30:00 09:31:00; p:101.5 102.5)
_
q)\l /db
q)select from t where i within 1 2
_
</code></pre>

<h3 id="14310-partitioned-tables-with-links">14.3.10 Partitioned Tables with Links<a class="headerlink" href="14_Introduction_to_Kdb+.1#14310-partitioned-tables-with-links" title="Permanent link">&para;</a></h3>
<p>You can create links between tables in the same partitioned database with the following restriction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A link column in the slice of a partitioned table must be intra-partition – i.e., it must refer to another table in the same slice. In particular, you cannot link across days in a daily partitioned database.</p>
</div>
<p>Since the daily slices are splayed tables, the mechanics of creating links for partitioned tables are the same as for splayed tables. We first demonstrate how to create a link as the slices are created in memory and splayed. Again we avoid symbols for simplicity; to include them, add a call to <code>.Q.en</code> as in previous examples.</p>
<p>We create two days of linked tables in a fresh <code>/db</code>.</p>
<pre><code class="q">q)t1:([] id:101 102 103; v:1.1 2.2 3.3)
q)`:/db/2015.01.01/t1/ set t1
_
q)`:/db/2015.01.01/t2/ set ([] id:`t1!t1[`id]?103 101 101 102; n:10 20 30 40)
_
q)`:/db/2015.01.02/t1/ set t1
_
q)`:/db/2015.01.02/t2/ set ([] id:`t1!t1[`id]?105 104 104; n:50 60 70)
_
</code></pre>

<p>Now we map the root and use dot notation on the link column.</p>
<pre><code class="q">q)\l /db
q)select date,n,id.v from t2 where date in 2015.01.01 2015.01.02
_
</code></pre>

<p>Adding a link column to persisted partitions is only a bit more complicated. Here we create a link on (enumerated) symbol columns. In a fresh <code>/db</code> we first create the partitioned tables without the link.</p>
<pre><code class="q">q)`:/db/2015.01.01/t1/ set .Q.en[`:/db;] ([] id:`c`b`a; c1: 10 20 30)
_
q)`:/db/2015.01.02/t1/ set .Q.en[`:/db;] ([] id:`x`a; c1: 40 50)
_
q)`:/db/2015.01.01/t2/ set .Q.en[`:/db;] ([]id:`a`b`a`c; c2: 1 2 3 4.)
_
q)`:/db/2015.01.02/t2/ set .Q.en[`:/db;] ([] id:`x`a`x; c2:5 6 7.)
_
</code></pre>

<p>Presumably at a later time, we add the link column to <code>t2</code> in each partition, making sure to update the <code>.d</code> files.</p>
<pre><code class="q">q)`:/db/2015.01.01/t2/t1lnk set
`t1!get[`:/db/2015.01.01/t1/id]?get[`:/db/2015.01.01/t2/id]
_
q)`:/db/2015.01.01/t2/.d set get[`:/db/2015.01.01/t2/.d],`t1lnk
_
q)`:/db/2015.01.02/t2/t1lnk set
`t1!get[`:/db/2015.01.02/t1/id]?get[`:/db/2015.01.02/t2/id]
_
q)`:/db/2015.01.02/t2/.d set get[`:/db/2015.01.02/t2/.d],`t1lnk
_
</code></pre>

<p>Now we can map the root and use dot notation.</p>
<pre><code class="q">q)select date,id,t1lnk.c1,c2 from t2 where date&lt;=2015.01.02
_
</code></pre>

<h2 id="144-segmented-tables">14.4 Segmented Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#144-segmented-tables" title="Permanent link">&para;</a></h2>
<p>We saw in the previous section that queries against partitioned tables execute separately across the partitions. When q is started without slaves this is a memory win but not a performance win, except for the reduced amount of data manipulation required. When q is started with slaves this can offer significant performance enhancement for compute-bound queries.</p>
<p>In large timeseries databases, the queries are often I/O-bound. In this case, the multiple slaves for a partitioned query will mostly be waiting on I/O (or Godot). The solution requires multiple I/O channels so that data retrieval and processing can occur in parallel. Kdb+ provides another level of data decomposition to enable parallel processing in this scenario.</p>
<p>Traditional kdb+ parlance did not distinguish between this level and the basic partitioning we encountered in the last section. We find this confusing and, at the suggestion of Simon Garland of Kx, have introduced the terminology of <em>segmentation</em>.</p>
<h3 id="1441-segments">14.4.1 Segments<a class="headerlink" href="14_Introduction_to_Kdb+.1#1441-segments" title="Permanent link">&para;</a></h3>
<p>Segmentation is an additional level of structure on top of partitioning. <em>Segmentation</em> spreads a partitioned table’s records across multiple directories that have the same structure as the root directory in a partitioned database. Each pseudo-root, called a <em>segment</em>, is thus a directory that contains a collection of partition directories. The segment directories are presumably on independent I/O channels so that data retrieval can occur in parallel.</p>
<p>You can use any criteria to decompose partition slices, as long as the results are conforming record subsets that are disjoint and complete – i.e., they reconstitute the original table with no omissions or duplication. The decomposition can be along rows, along partitions or by some combination thereof, but it cannot occur only along columns since all records must conform across the decomposition.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>You must ensure that the segments conform and are complete and disjoint, since kdb+ will not check this when you write the data files. In particular, overlapping segments will result in duplicate records in query results and an incomplete decomposition will result in dropped records.</p>
</div>
<p><strong>Big Picture (3)</strong>: .We view a segmented table as a three-dimensional persisted form: the table is cut vertically by splaying, sliced horizontally by partitions and is additionally segmented across physical locations. The primary purpose of the third dimension is to allow operations against the tables to take advantage of parallel I/O and concurrent processing. Following is an abstract representation of segmentation:</p>
<p><em>segment1</em></p>
<table>
<thead>
<tr>
<th></th>
<th>column1</th>
<th>column2</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>partition*</td>
<td>▪</td>
<td>▪</td>
<td>…</td>
</tr>
<tr>
<td>partition*</td>
<td>▪</td>
<td>▪</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p><em>segment2</em></p>
<table>
<thead>
<tr>
<th></th>
<th>column1</th>
<th>column2</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>partition*</td>
<td>▪</td>
<td>▪</td>
<td>…</td>
</tr>
<tr>
<td>partition*</td>
<td>▪</td>
<td>▪</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p><em>…</em></p>
<p>Here each ▪ represents a (partial) column of a partition slice as an opaque entity.</p>
<p>In contrast to the partitioned table layout in which partitions reside under the root, the segment directories must <strong>not</strong> reside under the root. The only portion of a segmented table (other than the sym file for enumerated symbol columns) that lives in the root is a file called par.txt containing the paths of the physical locations of the segments, one segment path per line.</p>
<p>Here is how the abstract segmentation discussed above would be laid out on the file system.</p>
<pre><code>/db
    [sym]
    par.txt
=============== &lt;- channel 1
/segment1
    /partition*
        /table*
        /table*
        …
    /partition*
        /table*
        /table*
        …
=============== &lt;- channel 2
/segment2
    /partition*
        /table*
        /table*
        …
    /partition*
        /table*
        /table*
        …
=============== …
</code></pre>

<p>To make this more concrete, we demonstrate how to segment daily trades (and eventually quotes) in several useful ways. To begin, we create segments by bucketing trades into alternating days of the week.</p>
<pre><code>/1                  &lt;- drive 1
    /2015.01.01
        /t          &lt;- day’s trades
    /2015.01.03
        /t          &lt;- day’s trades
    …
=============
/2                  &lt;- drive 2
    /2015.01.02
        /t          &lt;- day’s trades
    /2015.01.04
        /t          &lt;- day’s trades
    …
</code></pre>

<p>This segmentation represents grouping of partitions, so it is orthogonal to the partitioning. It is clearly complete and disjoint and is easily generalizable to round-robining every <em>n</em> business days.</p>
<p>We could alternatively create segments by splitting the daily slices into records with symbols starting with a-m and those starting with n-z. Here we are decomposing based on the values in a symbol column, which we could not do with simple partitioning.</p>
<pre><code>/am                 &lt;- drive 1
    /2015.01.01
        /t          &lt;- day’s trades for syms a-m
    /2015.01.02
        /t          &lt;- day’s trades for syms a-m
    …
=============
/nz &lt;- drive 2
    /2015.01.01
        /t          &lt;- day’s trades for syms n-z
    /2015.01.02
        /t          &lt;- day’s trades for syms n-z
    …
</code></pre>

<p>This segmentation clearly results in complete, disjoint subsets. It is not orthogonal to the partitioning because a single day's trades span multiple segments. It is easily generalizable to <em>n</em> segments by splitting the alphabet into <em>n</em> roughly equal portions.</p>
<p>Alternately, we can create segments by splitting the daily slices into trades from NYSE and trades from NASDAQ.</p>
<pre><code>/nyse               &lt;- drive 1
    /2015.01.01
        /t          &lt;- day’s trades for nyse
    /2015.01.02
        /t          &lt;- day’s trades for nyse
    …
=============
/nasd               &lt;- drive 2
    /2015.01.01
        /t          &lt;- day’s trades for nasd
    /2015.01.02
        /t          &lt;- day’s trades for nasd …
</code></pre>

<p>The segmentation is also not orthogonal to the partitioning since a single day's trades span multiple segments. It is clearly complete and disjoint and is easily generalizable to multiple exchanges – e.g., all Asian exchanges.</p>
<p>Finally, we provide an example of a non-uniform segmentation, in which some partitions span segments and others do not. The <em>A</em> segment contains trades from the beginning of day 1 until lunchtime of day 2. The <em>B</em> segment contains the trades from lunchtime of day 2 through the end of day 3. The <em>C</em> segment contains all trades from day 4. We rely on our understanding of the business logic to know that segmentation is disjoint and complete.</p>
<pre><code>/seg A              &lt;- drive 1
    /2015.01.01
        /t          &lt;- entire day’s trades
    /2015.01.02
        /t          &lt;- morning trades
=============
/seg B &lt;- drive 2
    /2015.01.02
        /t          &lt;- afternoon trades
    /2015.01.03
        /t          &lt;- entire day’s trades
=============
/seg C &lt;- drive 3
    /2015.01.04
        /t          &lt;- entire day’s trades
</code></pre>

<p>This sort of segmentation can be useful if your query patterns are not uniform across days.</p>
<h3 id="1442-segmentation-vs-partitions">14.4.2 Segmentation vs. Partitions<a class="headerlink" href="14_Introduction_to_Kdb+.1#1442-segmentation-vs-partitions" title="Permanent link">&para;</a></h3>
<p>We collect the following into tabular form so that you can use it for meditation.</p>
<table>
<thead>
<tr>
<th></th>
<th>Partitioned Table</th>
<th>Segmented Table</th>
</tr>
</thead>
<tbody>
<tr>
<td>Record location</td>
<td>All partitions (and hence all records) reside under the root directory.</td>
<td>None of the segments (and hence no records) reside under the root.</td>
</tr>
<tr>
<td>I/O channels</td>
<td>All partitions (and hence all records) reside on a single I/O channel.</td>
<td>The segments (and hence the records) should reside on multiple I/O channels.</td>
</tr>
<tr>
<td>Processing</td>
<td>Partitions loaded and processed sequentially in aggregation queries.</td>
<td>Given appropriate slaves and cores, aggregate queries load segments in parallel and process them concurrently.</td>
</tr>
<tr>
<td>Decomposition</td>
<td>Partition by grouping rows on the values of a virtual column of underlying integral type.</td>
<td>Segment by any criteria yielding disjoint and complete decomposition.</td>
</tr>
<tr>
<td>Symbols</td>
<td>Cannot partition on a symbol column</td>
<td>Can segment along a symbol column</td>
</tr>
<tr>
<td>Virtual Column</td>
<td>Partition column not stored. Virtual column values inferred from directory names</td>
<td>No special column associated with segmentation (virtual column from underlying partition still present)</td>
</tr>
</tbody>
</table>
<h3 id="1443-creating-segmented-tables">14.4.3 Creating Segmented Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1443-creating-segmented-tables" title="Permanent link">&para;</a></h3>
<p>There is no one-size-fits-all utility to create segments. Instead, you write a q program that places a subset of each partition slice into a segment. You can create segments and partitions at the same time by including logic in your data load script to extract slice subsets and place them in the appropriate directory on the appropriate drive.</p>
<p>Along with creating the partitions, you must also specify the locations of the segments in an ASCII text file <code>par.txt</code> located in the root. Each line of <code>par.txt</code> contains the path of one segment directory; symlinks are acceptable.</p>
<div class="admonition warning">
<p class="admonition-title">Important</p>
<p>The segment paths must not be under the root. Qbies who make this mistake will prefer Vogon poetry.</p>
</div>
<p>We illustrate the process by creating segmented tables for each example in <a href="14_Introduction_to_Kdb+.1#1441-segments">§14.4.1</a>. Our intent is to demonstrate how to create the segments and observe how execution of the query pieces the segment results back together. Initially we create the segments without concern for placing them on multiple drives and running multiple slaves, as we are not (yet) considering performance. That comes shortly.</p>
<p>We begin with the example in which daily slices are segmented alternately across two bins. This will result in roughly even access and will give good performance assuming the queries are uniformly distributed across days. The storage layout looks like,</p>
<pre><code>/1
    /2015.01.01
        /t
    /2015.01.03
        /t
/2
    /2015.01.02
        /t
    /2015.01.04
        /t
</code></pre>

<p>The corresponding <code>par.txt</code> file is,</p>
<pre><code>/1
/2
</code></pre>

<p>In a fresh directories <code>/1</code>, <code>/2</code> and <code>/db</code> we construct the segments and write the <code>par.txt</code> file.</p>
<pre><code class="q">q)`:/1/2015.01.01/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; s:`ibm`t; p:101 17f)
_
q)`:/2/2015.01.02/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; s:`ibm`t; p:101.5 17.5)
_
q)`:/1/2015.01.03/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; s:`ibm`t; p:103 16.5f)
`:/1/2015.01.03/t/
q)`:/2/2015.01.04/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; s:`ibm`t; p:102 17f)
_

q)`:/db/par.txt 0: (&quot;/1&quot;; &quot;/2&quot;)
_

q)\l /db
q)select from t where date within 2015.01.01 2015.01.04
_
</code></pre>

<p>Next we segment trades by symbol range. The storage layout looks like,</p>
<pre><code>/am
    /2015.01.01
    /2015.01.02
/nz
    /2015.01.01
    /2015.01.02
</code></pre>

<p>The corresponding <code>par.txt</code> file is,</p>
<pre><code class="q">/am
/nz
</code></pre>

<p>We begin with fresh directories <code>/am</code>, <code>/an</code>, and <code>/db</code> and a utility function to extract records for symbols within a range. Then we create the segments and write out the <code>par.txt</code> file.</p>
<pre><code class="q">q)extr:{[t;r] select from t where (`$1#'string sym) within r}

q)t1:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`t; p:101 17f)
q)`:/am/2015.01.01/t/ set extr[t1;`a`m]
_
q)`:/nz/2015.01.01/t/ set extr[t1;`n`z]
_

q)t2:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`t; p:101.5 17.5)
q)`:/am/2015.01.02/t/ set extr[t2;`a`m]
_
q) `:/nz/2015.01.02/t/ set extr[t2;`n`z]
_

q)`:/db/par.txt 0: (&quot;/am&quot;; &quot;/nz&quot;)
`:/db/par.txt

q)\l /db
q)select from t where date within 2015.01.01 2015.01.02
_
</code></pre>

<p>Next we segment trades by exchange. The storage layout looks like,</p>
<pre><code>/nyse
    /2015.01.01
        /t
    /2015.01.02
        /t
/nasd
    /2015.01.01
        /t
    /2015.01.02
        /t
</code></pre>

<p>The corresponding <code>par.txt</code> file is,</p>
<pre><code>/nyse
/nasd
</code></pre>

<p>Segment construction is completely analogous to that of the previous example. We begin with fresh directories <code>/nyse</code>, <code>/nasd</code>, <code>/db</code> and a utility to extract records by exchange.</p>
<pre><code class="q">q)extr:{[t;e] select from t where ex=e}

q)t1:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; s:`ibm`aapl; p:101 17f;ex:`n`o)
q)`:/nyse/2015.01.01/t/ set extr[t1;`n]
_
q)`:/nasd/2015.01.01/t/ set extr[t1;`o]
_

q)t2:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; s:`aapl`ibm; p:143 102f; ex:`o`n)
q)`:/nyse/2015.01.02/t/ set extr[t2;`n]
_
q)`:/nasd/2015.01.02/t/ set extr[t2;`o]
_

q)`:/db/par.txt 0: (&quot;/nyse&quot;; &quot;/nasd&quot;)
_

q)\l /db
q)select from t where date within 2015.01.01 2015.01.02
_
</code></pre>

<p>Finally we show how to distribute a day across segments. The storage layout looks like,</p>
<pre><code>/seg A
    /2015.01.01
    /2015.01.02
/seg B
    /2015.01.02
    /2015.01.03
/seg C
    /2015.01.04
</code></pre>

<p>The corresponding <code>par.txt</code> file is,</p>
<pre><code>/A
/B
/C
</code></pre>

<p>In fresh directories <code>/A</code>, <code>/B</code>, <code>/C</code> and <code>/db</code>,</p>
<pre><code class="q">q) t1:.Q.en[`:/db;] ([] ti:09:30:00 12:31:00; s:`ibm`t; p:101 17f)
q)`:/A/2015.01.01/t/ set t1
_
q)t2:.Q.en[`:/db;] ([] ti:09:31:00 12:32:00; s:`ibm`t; p:102 18f)
q)`:/A/2015.01.02/t/ set select from t2 where ti&lt;=12:00:00
_
q)`:/B/2015.01.02/t/ set select from t2 where ti&gt;12:00:00
_
q)t3:.Q.en[`:/db;] ([] ti:09:33:00 12:33:00; s:`ibm`t; p:103 19f)
q)`:/B/2015.01.03/t/ set t3
_
q)t4:.Q.en[`:/db;] ([] ti:09:34:00 12:35:00; s:`ibm`t; p:104 20f)
q)`:/C/2015.01.04/t/ set t4
_

q)`:/db/par.txt 0: (&quot;/A&quot;;&quot;/B&quot;;&quot;/C&quot;)
_

q)\l /db
q)select from t where date within 2015.01.01 2015.01.04
_
</code></pre>

<h3 id="1444-multiple-segmented-tables">14.4.4 Multiple Segmented Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1444-multiple-segmented-tables" title="Permanent link">&para;</a></h3>
<p>Multiple tables that share a partition can also be segmented. While there is no requirement that the tables be distributed similarly across the segmentation, they should do so if you expect to use links or joins between them. In this section, we create (vastly simplified) trades and quotes that share a segmentation in order to do joins.</p>
<p>Our actual segmentation layout is designed to allow parallel retrieval for <code>aj</code>. We first observe that it performs an equijoin on the sym and date columns, while it performs a non-equijoin on the time column. Thus we want all the time values for a given symbol and date in one segment. Consequently, segmentation by symbol range will allow parallelization of <code>aj</code> across symbols.</p>
<p>Here is a simple version of this scheme.</p>
<pre><code>/a_m &lt;- segment for first portion of alphabet
    /2015.01.01     &lt;- the specific day
        /t          &lt;- that day’s trades for symbols a-m
        /q          &lt;- that day’s quotes for symbols a-m
    /2015.01.02     &lt;- the specific day
        /t          &lt;- that day’s trades for symbols a-m
        /q          &lt;- that day’s quotes for symbols a-m
=================
/n_z                &lt;- segment for second portion of alphabet
    /2015.01.01     &lt;- the specific day
        /t          &lt;- that day’s trades for symbols n-z
        /q          &lt;- that day’s quotes for symbols n-z
    /2015.01.02     &lt;- the specific day
        /t          &lt;- that day’s trades for symbols n-z
        /q          &lt;- that day’s quotes for symbols n-z
=================
</code></pre>

<p>The corresponding <code>par.txt</code> file is,</p>
<pre><code>/a_m
/n_z
</code></pre>

<p>Setting up the segments and partitions is a matter of getting the details right. In our simplified example, we pretend that the directories <code>/am</code>and <code>/nz</code> reside on different drives. In fresh directories <code>/am</code>, <code>/nz</code> and <code>/db</code>,</p>
<pre><code class="q">q)extr:{[t;r] select from t where (`$1#'string sym) within r}
q)/ day 1
q)t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`t; p:101 17f)
q)q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`ibm`t`ibm; p:100.5 17 101)
q)`:/am/2015.01.01/t/ set extr[t;`a`m]
_
q)`:/nz/2015.01.01/t/ set extr[t;`n`z]
_
q)`:/am/2015.01.01/q/ set extr[q;`a`m]
)
q)`:/nz/2015.01.01/q/ set extr[q;`n`z]
_

q)/ day 2
q)t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`t`ibm; p:17.1 100.9)
q)q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`t`ibm`t;p:17 100.8 17.1)
q)`:/am/2015.01.02/t/ set extr[t;`a`m]
_
q)`:/nz/2015.01.02/t/ set extr[t;`n`z]
_
q)`:/am/2015.01.02/q/ set extr[q;`a`m]
_
q)`:/nz/2015.01.02/q/ set extr[q;`n`z]
_
q)`:/db/par.txt 0: (&quot;/am&quot;; &quot;/nz&quot;)
_

q)\l /db

q)dr:2015.01.01 2015.01.02
q)select from t where date within dr
_
q)select from q where date within dr
_
</code></pre>

<p>Now let’s do the <code>aj</code>. We could be naïve and pull all requisite data into the workspace, but this would be inefficient in memory and slow, assuming it would fit.</p>
<pre><code class="q">q)aj[`date`sym`ti;select from t where date within dr;
 select from q where date within dr]
_
</code></pre>

<p>Instead we start q with slaves and use <code>peach</code> to run things in parallel across the segmentation.</p>
<pre><code class="bash">$q -s 2
KDB+ ...
</code></pre>

<pre><code class="q">q)aj1:{aj[`sym`ti;select from t where date=d; select from q where date=d]}
q)raze aj1 peach 2015.01.01 2015.01.02
q)raze aj1 peach 2015.01.01 2015.01.02
_
</code></pre>

<h3 id="1445-query-execution-against-segmented-tables">14.4.5 Query Execution against Segmented Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1445-query-execution-against-segmented-tables" title="Permanent link">&para;</a></h3>
<p>The performance goal is to scale out by taking advantage of parallel I/O and concurrent processing. We would ideally like to achieve 100% saturation of the I/O channels and 100% utilization of each core. How do we approach these levels on a kdb+ server? The key insight in kdb+ design and tuning is that a vector calculation on in-memory data is much faster than retrieving data from storage. This suggests our first two design principles.</p>
<ol>
<li>
<p>Maximize the number of independent I/O channels to retrieve data in parallel.</p>
</li>
<li>
<p>Maximize server memory in order to allocate each slave thread as much memory as it needs.</p>
</li>
</ol>
<p>Suppose we can satisfy these two objectives by having storage devices attached to the kdb+ server over <em>n</em> independent I/O channels – for example, the author’s laptop has SSD storage that appears as multiple independent I/O channels. In this scenario, we are led to our next observation.</p>
<ol start="3">
    <li>Create <em>n</em> segments to spread data retrieval across the <em>n</em> channels in order to maximize I/O parallelization.</li>
</ol>

<p>To ensure that data can be processed from all <em>n</em> channels simultaneously and that no two threads contend for data, we are led to our final objective.</p>
<ol start="4">
    <li>Have (at least) <em>n</em> slave threads</li>
</ol>

<p>The precise form of segmentation and number of slaves will depend on the actual data and queries.</p>
<p>Now assuming we have such an environment, does kdb+ execute a query against a segmented table in our scenario of <em>n</em> segments and <em>n</em> slaves.? Essentially, it decomposes a qualifying query into two steps via map-reduce:</p>
<ul>
<li>Map: a revised form of the original query that executes on each segment</li>
<li>Reduce: aggregate the segment results</li>
</ul>
<p>The use of map-reduce allows kdb+ to perform preliminary calculations as close to the data as possible and to perform aggregation centrally at the last step.</p>
<p>To begin, kdb+ compares the query’s requisite partitions to the segment layout in <code>par.txt</code> and determines the footprint of the target partitions on each segment. The result is a nested list, each item being the partition list for one segment.</p>
<p>To execute the map step, kdb+ creates a revised query containing the map sub-operation from the original query, which it dispatches to all <em>n</em> slaves via <code>peach</code>. Each slave is provided the partition list for one segment and computes the revised query for its segment. For example, the revised query for <code>avg</code> is:</p>
<blockquote>
<p>Compute the sum and count of the sublist</p>
</blockquote>
<p>With this knowledge, we examine execution <strong>within</strong> one slave, where the revised query is applied against a segment’s partition footprint. Here kdb+ <strong>sequentially</strong> applies the map sub-operations of the original query across the targeted partitions to obtain partition result tables that it then collects into a list representing one segment result.</p>
<p>Now we stand back and examine execution <strong>across</strong> the slaves by squinting to make partition detail disappear. At this level, the original query’s map step has <em>n</em> slaves retrieving segment data <strong>in parallel</strong> and calculating segment results. Once all slaves complete, the nested list of segment results is flattened and reordered by partition value.</p>
<p>Finally, kdb+ employs the original query reduce step to combine the full list of ordered partition results into the query result table. Whew!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Kdb+ treats a vanilla partitioned table – i.e., without a <code>par.txt</code> – as having a single segment. The astute reader will realize that the description in <a href="14_Introduction_to_Kdb+.1#1433-creating-partitioned-tables">§14.3.3</a> is actually the degenerate case of this section.</p>
</div>
<h3 id="1446-balancing-slaves-and-cores">14.4.6 Balancing Slaves and Cores<a class="headerlink" href="14_Introduction_to_Kdb+.1#1446-balancing-slaves-and-cores" title="Permanent link">&para;</a></h3>
<p>In our quest to reach 100% saturation of I/O and CPU, we consider how to optimize the use of slaves and cores. As seen in the previous section, the query via map-reduce provides good progress toward our original objective of I/O saturation. The slaves can load data from all <em>n</em> channels in parallel without contention.</p>
<p>We now investigate channel and core utilization. Since kdb+ will only use as many slaves to process a query as there are segments in the query footprint, we consider two cases.</p>
<p><strong>I/O-bound</strong>: Assuming that the query has light calculation compared to data retrieval (common in kdb+), having <em>n</em> slaves on <em>n</em> cores is close to optimal: most of the time, all <em>n</em> slaves will be waiting for data. When a partition load completes, there will be a brief burst of computation, followed by another long load. So we conclude for this scenario:</p>
<p><em>n</em> channels =&gt; <em>n segments</em> =&gt; <em>n</em> slaves =&gt; <em>n</em> cores</p>
<p><strong>Balanced I/O-compute</strong>: Consider the scenario in which both the I/O and calculation are intensive. While one slave is waiting on data, another slave on the same core could be crunching; conversely, while one slave is crunching another slave on that core could be loading data. Thus to maximize channel and core utilization, we actually want <em>2n</em> slaves on <em>n</em> cores. We conclude that in this scenario we should have <em>2n</em> segments, two per channel. On average, there will be one slave per core loading data and one slave per core crunching the data it has just loaded.</p>
<p><em>n</em> channels =&gt; <em>2n segments</em> =&gt; <em>2n</em> slaves =&gt; <em>n</em> cores</p>
<p>These conclusions rely on many implicit assumptions that we have glossed over. In practice, you should view them as guidelines, with the goal of feeding data to kdb+ as fast as possible. The optimum configuration for your situation will depend on your particular query mix. For example, queries that do VWAP calculations are closer to the first scenario, whereas queries doing regression analysis are closer to the second.</p>
<p>A good strategy is to construct your initial configuration using one of the above scenarios. Then load a good approximation of your anticipated data and query mix, and simulate a realistic user load. Observe the I/O saturation and CPU utilization and adjust the number of slaves and cores allocated to the q process accordingly.</p>
<h3 id="1447-sample-performance-data">14.4.7 Sample Performance Data<a class="headerlink" href="14_Introduction_to_Kdb+.1#1447-sample-performance-data" title="Permanent link">&para;</a></h3>
<p>Our examples are based on simulated trade data randomly generated to match one month of US equity data spanning August and September 2014. The data is in the table <code>trade</code>, whose most significant columns <code>time</code>, <code>sym</code>, <code>tp</code> and <code>ts</code> represent respectively arrival time, instrument symbol, trade price and trade size columns. The trade data is partitioned by date.</p>
<p>The following output is generated from a version of kdb+ that has been instrumented to show the intermediate steps during query execution. The first example query shows how the simple aggregate <code>avg tp</code> is decomposed into the pair sum and count in the map step, followed by division of the sums of sums by the sum of counts for the reduce step. Here the data is not segmented – i.e., there is no <code>par.txt</code> file.</p>
<p>The added instrumentation exposes 3 stages of execution of a query.</p>
<ol>
<li>
<p>Analyze query:</p>
<ul>
<li>
<p>Decompose query into map and reduce components (if appropriate)</p>
</li>
<li>
<p>Determine and apply partition constraints</p>
</li>
<li>
<p>Map query onto segments and partitions (query plan)</p>
</li>
</ul>
</li>
<li>
<p>Execute map step, if appropriate</p>
</li>
<li>
<p>Compute final result (reduce step)</p>
</li>
</ol>
<pre><code class="q">q)select avg tp from trade where date in -3#date
&quot;--- map/reduce: input aggregates, map query, reduce query ---&quot; (,`tp)!,(avg;`tp)
`0`1!((sum;($[&quot;f&quot;];`tp));(#:;`i))
(,`tp)!,(%;(sum;`0);(sum;`1))

&quot;--- query plan: segments/partitions ---&quot; (`trade;();()!();`0`1!((sum;($[&quot;f&quot;];`tp));(#:;`i)))
2014.09.24 2014.09.25 2014.09.28

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;();()!();`0`1!((sum;($[&quot;f&quot;];`tp));(#:;`i)))
`:.
2014.09.24
+`0`1!(,1.419538e+10;,27914938)

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;();()!();`0`1!((sum;($[&quot;f&quot;];`tp));(#:;`i)))
`:. 2014.09.25 +`0`1!(,1.419318e+10;,24485503)

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;();()!();`0`1!((sum;($[&quot;f&quot;];`tp));(#:;`i)))
`:. 2014.09.28 +`0`1!(,1.388645e+10;,20162485)

&quot;--- query plan result ---&quot; (+`0`1!(,1.419538e+10;,27914938);+`0`1!(,1.419318e+10;,24485503); +`0`1!(,1.388645e+10;,20162485))

&quot;--- final result ---&quot; tp -------- 582.5979
</code></pre>

<p>First note that <code>`0</code> and <code>`1</code> are used as intermediate columns. Observe that <code>avg tp</code> is decomposed into a map step.</p>
<pre><code class="q">`1:sum &quot;f&quot;$tp and `0:count i
</code></pre>

<p>and a reduce step</p>
<pre><code class="q">tp:(sum `0)%sum `1.
</code></pre>

<p>Also observe that expressions are displayed in their parse-tree format and that count is expressed as its k equivalent: the monadic form of <code>#</code>.</p>
<p>The next example uses <code>par.txt</code> to segment the data into four segments: (<code>/d/d1/data</code>, <code>/d/d2/data</code>, <code>/d/d3/data</code>, <code>/d/d4/data</code>). It also uses a by-date clause to sidestep the need to break up the query into map and reduce components (our data is partitioned by date). For clarity, we execute the query only on the last 16 partitions as well as on a subset of symbols. Observe that the "query plan" contains more information than that of the previous example: the query, a list of all partitions, a list of all segments, and a nested list of partitions belonging to segments.</p>
<pre><code class="q">q)select avg tp by date from trade where date in -16#date,sym in syms

&quot;--- query plan: segments/partitions ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) 2014.08.18 2014.08.19 2014.08.20 2014.08.21 2014.08.24 2014.08.25 2014.08.26 2014.08.27 2014.08.28 2014.08.31 2014.09.01 2014.09.02 2014.09.03 2014.09.04 2014.09.08 2014.09.09 `:/d/d1/data`:/d/d2/data`:/d/d3/data`:/d/d4/data ((`:/d/d1/data;2014.08.21 2014.08.25 2014.09.02); (`:/d/d2/data;2014.08.18 2014.08.26 2014.09.03); (`:/d/d3/data;2014.08.19 2014.08.27 2014.08.31 2014.09.04 2014.09.08); (`:/d/d4/data;2014.08.20 2014.08.24 2014.08.28 2014.09.01 2014.09.09))

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d1/data
2014.08.21 +(,`tp)!,,15.42632

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d1/data
2014.08.25
+(,`tp)!,,15.04996

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d1/data
2014.09.02
+(,`tp)!,,14.16648

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d2/data 2014.08.18
+(,`tp)!,,14.16883
</code></pre>

<p>… (some output removed for brevity) …</p>
<pre><code class="q">&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
2014.09.08
+(,`tp)!,,15.59198

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data 2014.08.20
+(,`tp)!,,15.2657

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data
2014.08.24 +(,`tp)!,,14.75603

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data 2014.08.28
+(,`tp)!,,14.37194

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data 2014.09.01
+(,`tp)!,,13.25797

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data 2014.09.09
+(,`tp)!,,14.98316

&quot;--- query plan result ---&quot; (+(,`tp)!,,14.16883;+(,`tp)!,,15.05272;+(,`tp)!,,15.2657;+(,`tp)!,,15.42632; +(,`tp)!,,14.75603;+(,`tp)!,,15.04996;+(,`tp)!,,15.69218;+(,`tp)!,,15.53095; +(,`tp)!,,14.37194;+(,`tp)!,,14.32488;+(,`tp)!,,13.25797;+(,`tp)!,,14.16648; +(,`tp)!,,15.58938;+(,`tp)!,,16.1427;+(,`tp)!,,15.59198;+(,`tp)!,,14.98316)

&quot;--- final result ---&quot;
date      | tp
----------| --------
2014.08.18| 14.16883
2014.08.19| 15.05272
2014.08.20| 15.2657
2014.08.21| 15.42632
2014.08.24| 14.75603
2014.08.25| 15.04996
2014.08.26| 15.69218
2014.08.27| 15.53095
2014.08.28| 14.37194
2014.08.31| 14.32488
2014.09.01| 13.25797
2014.09.02| 14.16648
2014.09.03| 15.58938
2014.09.04| 16.1427
2014.09.08| 15.59198
2014.09.09| 14.98316
</code></pre>

<p>The previous example was run with no slaves – i.e., on a single-threaded q process. Consequently, the queries run sequentially across segments and partitions.</p>
<p>Now observe what happens when we match the number of slaves to the number of segments in our database by invoking q with <code>-s 4</code>.</p>
<pre><code class="q">q)select avg tp by date from trade where date in -16#date,sym in syms

&quot;--- query plan: segments/partitions ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) 2014.08.18 2014.08.19 2014.08.20 2014.08.21 2014.08.24 2014.08.25 2014.08.26 2014.08.27 2014.08.28 2014.08.31 2014.09.01 2014.09.02 2014.09.03 2014.09.04 2014.09.08 2014.09.09 `:/d/d1/data`:/d/d2/data`:/d/d3/data`:/d/d4/data ((`:/d/d1/data;2014.08.21 2014.08.25 2014.09.02); (`:/d/d2/data;2014.08.18 2014.08.26 2014.09.03); (`:/d/d3/data;2014.08.19 2014.08.27 2014.08.31 2014.09.04 2014.09.08); (`:/d/d4/data;2014.08.20 2014.08.24 2014.08.28 2014.09.01 2014.09.09))

&quot;--- partition query: query, segment, partition, result ---&quot;
&quot;--- partition query: query, segment, partition, result ---&quot;
&quot;--- partition query: query, segment, partition, result ---&quot;
(`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d1/data
2014.08.21

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data
2014.08.20 (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
2014.08.19 (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d2/data
2014.08.18
+(,`tp)!,,15.55121

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
2014.08.27
+(,`tp)!,,15.47055 +(,`tp)!,,15.21819

&quot;--- partition query: query, segment, partition, result ---&quot;
&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d2/data
2014.08.26 (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data
2014.08.24
+(,`tp)!,,14.81711
&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d1/data
2014.08.25
+(,`tp)!,,14.92875

&quot;--- partition query: query, segment, partition, result ---&quot; +(,`tp)!,,16.07275
&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
2014.08.31
+(,`tp)!,,15.55499 (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data
2014.08.28

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d2/data
2014.09.03
+(,`tp)!,,13.43061 +(,`tp)!,,15.29159 +(,`tp)!,,12.64993

&quot;--- partition query: query, segment, partition, result ---&quot;
&quot;--- partition query: query, segment, partition, result ---&quot;
&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
`:/d/d4/data
2014.09.04
2014.09.01
+(,`tp)!,,176.6311
`:/d/d1/data
2014.09.02
+(,`tp)!,,151.7784
+(,`tp)!,,13.67089

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data
2014.09.09
+(,`tp)!,,179.799

&quot;--- partition query: query, segment, partition, result ---&quot; (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
2014.09.08
+(,`tp)!,,193.7031
+(,`tp)!,,48.75286

&quot;--- query plan result ---&quot; (+(,`tp)!,,15.47055;+(,`tp)!,,15.55121;+(,`tp)!,,15.21819;+(,`tp)!,,14.81711; +(,`tp)!,,16.07275;+(,`tp)!,,15.29159;+(,`tp)!,,15.55499;+(,`tp)!,,14.92875; +(,`tp)!,,12.64993;+(,`tp)!,,13.43061;+(,`tp)!,,13.67089;+(,`tp)!,,151.7784; +(,`tp)!,,176.6311;+(,`tp)!,,179.799;+(,`tp)!,,193.7031;+(,`tp)!,,48.75286)

&quot;--- final result ---&quot;
date      | tp
----------| --------
2014.08.18| 15.47055
2014.08.19| 15.55121
2014.08.20| 15.21819
2014.08.21| 14.81711
2014.08.24| 16.07275
2014.08.25| 15.29159
2014.08.26| 15.55499
2014.08.27| 14.92875
2014.08.28| 12.64993
2014.08.31| 13.43061
2014.09.01| 13.67089
2014.09.02| 151.7784
2014.09.03| 176.6311
2014.09.04| 179.799
2014.09.08| 193.7031
2014.09.09| 48.75286
</code></pre>

<p>Here the output from four slaves running concurrently is interleaved. One slave executes for each segment, with each slave executing the query on its segment sequentially across its partitions. We see how an appropriately configured server can take advantage of available I/O bandwidth to speed up query execution using segments and slaves.</p>
<h2 id="145-utilities-for-splaying-and-partitioning">14.5 Utilities for Splaying and Partitioning<a class="headerlink" href="14_Introduction_to_Kdb+.1#145-utilities-for-splaying-and-partitioning" title="Permanent link">&para;</a></h2>
<p>The <code>.Q</code> namespace contains useful functions for creating and maintaining splayed and partitioned tables. Although Kx disclaims support for customer use, nearly everyone uses them and they have become <em>de facto</em> standard. In this section, we describe the more commonly used entries and demonstrate their use.</p>
<h3 id="1451-qqp">14.5.1 <code>.Q.qp</code><a class="headerlink" href="14_Introduction_to_Kdb+.1#1451-qqp" title="Permanent link">&para;</a></h3>
<p>The monadic <code>.Q.qp</code> asks the residency of its table argument. It returns <code>1b</code> if its argument is a partitioned table mapped into memory, <code>0b</code> if it is splayed and 0 for anything else. In a fresh <code>/db</code>,</p>
<pre><code class="q">q)`:/db/tser set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)`:/db/tsplay/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)`:/db/2015.01.01/tpart/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)\l /db
q).Q.qp tser
0
q).Q.qp tsplay
0b
q).Q.qp tpart
1b
</code></pre>

<h3 id="1452-qen">14.5.2 <code>.Q.en</code><a class="headerlink" href="14_Introduction_to_Kdb+.1#1452-qen" title="Permanent link">&para;</a></h3>
<p>The dyadic <code>.Q.en</code> takes a symbolic file handle of a root directory as its first argument and a table as its second argument. As a side effect, it creates a list sym comprising the unique items across all symbol columns and writes it to an eponymous file in the specified directory. It returns a table obtained from the original table by enumerating its symbol column(s) over sym.</p>
<p>In a fresh <code>/db</code>,</p>
<pre><code class="q">q)sym
'sym
q).Q.en[`:/db;] ([] s:`a`b`v;v:10 20 30)
s v
----
a 10
b 20
v 30
q)sym
`a`b`v
q)get `:/db/sym
`a`b`v
</code></pre>

<p>Here is more detail on the actual sequence of operations for <code>.Q.en</code>.</p>
<ul>
<li>The variable <code>sym</code> is created (in memory) by loading the file <code>sym</code> from the specified root, should such exist, or as the empty symbol list if not. An existing <code>sym</code> variable in the workspace is <strong>overwritten</strong> in this step.</li>
<li>All symbol columns of (a copy of) the table are conditionally enumerated over the sym list.</li>
<li>The <code>sym</code> variable is serialized to the specified root directory.</li>
<li>The enumerated table is returned from the function application.</li>
</ul>
<h3 id="1453-qpv">14.5.3 <code>.Q.pv</code><a class="headerlink" href="14_Introduction_to_Kdb+.1#1453-qpv" title="Permanent link">&para;</a></h3>
<p>The variable <code>.Q.pv</code> is a list containing the values of the partition domain – i.e., the values corresponding to the slice directories actually found in the root. This is useful if you need to iterate over all the partitions.</p>
<p>In a fresh <code>/db</code>,</p>
<pre><code class="q">q)`:/db/2015.01.01/t/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)`:/db/2015.01.03/t/ set ([] c1:4 5; 4.4 5.5)
`_
q)\l /db
q).Q.pv
2015.01.01 2015.01.03
</code></pre>

<h3 id="1454-qind">14.5.4 <code>.Q.ind</code><a class="headerlink" href="14_Introduction_to_Kdb+.1#1454-qind" title="Permanent link">&para;</a></h3>
<p>As we saw in <a href="14_Introduction_to_Kdb+.1#143-partitioned-tables">§14.3</a>, the virtual column <code>i</code> reflects the <strong>relative</strong> row number in a partitioned table. That is, the value of <code>i</code> is the offset of the records within the partition slice. How to retrieve records by absolute within a partition or segmented?</p>
<p>A masochist might use a q expression to determine the partition and relative row for the absolute row number. It is less painful to use the dyadic <code>.Q.ind</code>, whose first argument is a partitioned table and whose second argument is a <strong>list</strong> of long values representing absolute row numbers. The result is a table in memory. You must enlist a single index value.</p>
<p>In a fresh <code>/db</code>,</p>
<pre><code class="q">q)`:/db/2015.01.01/t/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)`:/db/2015.01.03/t/ set ([] c1:4 5; c2:4.4 5.5)
_
q)\l /db
q)select from t where date within 2015.01.01 2015.01.03
_
q).Q.ind[t;1 3]
date c1 c2
-----------------
2015.01.01 2 2.2
2015.01.03 4 4.4
q).Q.ind[t;enlist 2]
_
</code></pre>

<h3 id="1455-qdpft">14.5.5 <code>.Q.dpft</code><a class="headerlink" href="14_Introduction_to_Kdb+.1#1455-qdpft" title="Permanent link">&para;</a></h3>
<p>The utility .<code>Q.dpft</code> assists in creating partitioned and segmented tables by incorporating the functionality of <code>.Q.en</code> at a slightly higher level. It is convenient when partitions are loaded and written out iteratively.</p>
<p>The first parameter is the symbolic file handle of the database root directory. The second parameter is the q data value that will become the name of the partition subdirectory. The third parameter is the name of the field to which the <code>`p#</code> attribute is applied (usually <code>`sym</code> for trades and quotes). The last parameter is the table name.</p>
<p>The <code>.Q.dpft</code> function rearranges (a copy of) the named table so that the partition column is first and the parted column is second, and then splays it into the specified partition in the specified directory. When appropriate, it enumerates all symbol columns over <code>sym</code> and saves a sym list in the root. The result is the table name if the operation is successful.</p>
<p><strong>Notes</strong>:</p>
<ul>
<li>Because the final parameter is a table name, this function cannot be applied to a local variable.</li>
<li>The table columns must be simple or compound lists.</li>
<li>The source table cannot be a keyed table.</li>
</ul>
<p>We recycle our favorite example, using <code>.Q.dpft</code> to write it as a partitioned table into a fresh <code>/db</code>.</p>
<pre><code class="q">q)t:([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101.5 33.5)
q).Q.dpft[`:/db;2015.01.01;`sym;`t]
_
q)t:([] ti:09:31:00 09:32:00; sym:`ibm`msft; p:101 33f)
q).Q.dpft[`:/db;2015.01.02;`sym;`t]
_
q)\l /db
q)select from t where date in 2015.01.01 2015.01.02
_
</code></pre>

<h3 id="1456-qfs">14.5.6 <code>.Q.fs</code><a class="headerlink" href="14_Introduction_to_Kdb+.1#1456-qfs" title="Permanent link">&para;</a></h3>
<p>In many cases, splayed tables (as well as partitioned or segmented slices) are too large to fit into memory. Thus, we face the dilemma of how to create such tables, since splaying requires the table to be in memory. The utility <code>.Q.fs</code> comes to the rescue by allowing us to process text files in "chunks."</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The chunk size used by <code>.Q.fs</code> is hard-coded. If this does not provide adequate performance may wish to use <code>.Q.fsn</code>, which exposes the chunk size as an additional parameter. The optimal chunk size will vary for each application.</p>
</div>
<p>Loosely speaking, <code>.Q.fs</code> applies a function to the records of a text file in “chunks” instead of processing the entire file in one gulp. It iterates the function over a number of bite-sized record lists. As a trivial warm-up, we create a text file containing the first 100000 non-negative integers, one per line and we chunk the calculation of their squares. (The call to <code>0N!</code> enables us to see the result of each chunk as it is processed.)</p>
<pre><code class="q">q)`:/data/L 0: string til 100000
_
q).Q.fs[{0N!x*x};`:/data/L]
0 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 441 484..
560979225 561026596 561073969 561121344 561168721 561216100 561263481 5613108..
2071888324 2071979361 2072070400 2072161441 2072252484 2072343529 2072434576 ..
4536157201 4536291904 4536426609 4536561316 4536696025 4536830736 4536965449 ..
7953785856 7953964225 7954142596 7954320969 7954499344 7954677721 7954856100 ..
588890
</code></pre>

<p>While chunking provides no material benefit in this trivial example, it is easily adaptable to larger problems. Assume we have a CSV file containing one day’s pseudo-trade records (here we manufacture one).</p>
<pre><code class="q">q)ct:00:00:00.000+(10*(til 100000))mod `int$24:00:00.000
q)ix:100000?til 2
q)cs:(`ibm`ms) ix
q)cp:(115 25@ix)+-1.+100000?1.
q)trade:([] ti:ct; sym:cs; px:cp)
q)save `:/data/trade.csv
_
q) read0 `:/data/trade.csv
&quot;ti,sym,px&quot;
&quot;00:00:00.000,ibm,114.767&quot;
&quot;00:00:00.010,ibm,114.7566&quot;
&quot;00:00:00.020,ibm,114.1825&quot;
…
</code></pre>

<p>We intend to save this data into a kdb+ daily partition slice, but suppose that loading it all at once results in a WSFULL error because our q process has insufficient memory. We demonstrate how to read the CSV file and write out to the partition slice in chunks. For convenience, we wrap the read and symbol enumeration into a function <code>ldchunk</code>. Then we use <code>.Q.fs</code>to iterate <code>ldchunk</code> over the chunks, upserting each result to the partition directory. Again we instrument with <code>0N!</code> to see each chunk result.</p>
<pre><code class="q">q)ldchunk:{.Q.en[`:/db] flip `time`sym`price!(&quot;TSF&quot;;&quot;,&quot;) 0: x}
q).Q.fs[{0N!.[`:/db/2015.01.01/t/;();,;ldchunk x]}] `:/data/trade.csv
`:/db/2015.01.01/t/
`:/db/2015.01.01/t/
`:/db/2015.01.01/t/
…
2638673j
</code></pre>

<p>We verify that the partition is properly written.</p>
<pre><code class="q">q)\l /db
q)select from t where date=2015.01.01
_
</code></pre>

<p>When performance matters in the real world, we would proceed to sort the completed partition slice by time within sym and apply the <code>`p#</code> attribute to the <code>sym</code> column.</p>
<pre><code class="q">q)`sym`time xasc `:/db/2015.01.01/t
_
q)@[`:/db/2015.01.01/t; `sym; `p#]
_
q)\l /db
q)meta t
c    | t f a
-----| -----
date | d
time | t
sym  | s p
price| f
</code></pre>

<h3 id="1457-qchk">14.5.7 <code>.Q.chk</code><a class="headerlink" href="14_Introduction_to_Kdb+.1#1457-qchk" title="Permanent link">&para;</a></h3>
<p>The utility <code>.Q.chk</code> is a monadic function whose argument is the symbolic file handle of a root directory. It examines each partition sub-directory in the root and writes an empty splayed slice of the appropriate form wherever a table is missing in a partition.</p>
<p>We reconstruct our trades and quotes example, this time using <code>.Q.dpft</code>. In a fresh <code>/db</code>,</p>
<pre><code class="q">q)t:([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101 33f)
q).Q.dpft[`:/db;2015.01.01;`sym;`t]
_
q)t:([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101.5 33.5)
q).Q.dpft[`:/db;2015.01.02;`sym;`t]
_
q)q:([] ti:09:30:00 09:31:00; sym:`ibm`msft;b:100.75 32.75; a:101.25 33.25f)
q).Q.dpft[`:/db;2015.01.01;`sym;`q]
_
q)q:([] ti:09:30:00 09:31:00; sym:`ibm`msft;b:101.25 33.25; a:101.75 33.75)
q).Q.dpft[`:/db;2015.01.02;`sym;`q]
_
</code></pre>

<p>Now we introduce two new partitions, each containing a slice for just one table.</p>
<pre><code class="q">q)q:([] ti:09:30:00 09:31:00; sym:`ibm`msft;b:101. 33.; a:101.5 34f)
q).Q.dpft[`:/db;2009.01.03;`sym;`q]
_
q) t:([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:102 34f)
q).Q.dpft[`:/db;2009.01.04;`sym;`t]
_
</code></pre>

<p>This will make the table <code>q</code> disappear since it is not in the most recent partition; also a query for <code>t</code> fail on 2015.01.03. We use <code>.Q.chk</code> to fix things.</p>
<pre><code class="q">q).Q.chk `:/db
()
()
,`:/db/2009.01.04
,`:/db/2009.01.03
q)select from t where date=2015.01.03
ti sym p
--------
q)select from q where date=2015.01.04
ti sym b a
----------
</code></pre>

<p>Notice that <code>.Q.chk</code> tells you which partitions it is fixing but not which tables.</p>
<h3 id="1458-qview">14.5.8 <code>.Q.view</code><a class="headerlink" href="14_Introduction_to_Kdb+.1#1458-qview" title="Permanent link">&para;</a></h3>
<p>The monadic <code>.Q.view</code> is handy when you are executing queries against partitioned or segmented tables. Recall that multiple tables can share the partitioning. The argument of <code>.Q.view</code> is a list of partition values that acts as a filter for all queries against any partitioned table in the database. Otherwise put, the practical effect of applying <code>.Q.view</code> is to add its argument as a constraint in the first sub-phrase of the where clause of every query. This can guard against runaway queries that ask for all historical data, for example.</p>
<p>In the following example, we create a daily partitioned table with three days of data in a fresh <code>/db</code>. By using <code>.Q.view</code> to restrict the view, we reign in the unqualified query.</p>
<pre><code class="q">q)`:/db/2015.01.01/t/ set ([] ti:09:30:00 09:31:00; p:101 102f)
`:/db/2015.01.01/t/
q)`:/db/2015.01.02/t/ set ([] ti:09:30:00 09:31:00; p:100 100f)
`:/db/2015.01.02/t/
q)`:/db/2015.01.03/t/ set ([] ti:09:30:00 09:31:00; p:103 104f)
`:/db/2015.01.03/t/

q)\l /db
q).Q.view 2015.01.02 2015.01.03
q)select from t / normally dangerous!
date       ti       p
-----------------------
2015.01.02 09:30:00 100
2015.01.02 09:31:00 100
2015.01.03 09:30:00 103
2015.01.03 09:31:00 104
</code></pre>

<p>This is especially useful when you are testing or when you expose large historical databases to users who are prone to forget that they must qualify their queries by date. To reset the default view to all partitions, invoke <code>.Q.view</code> niladically.</p>
<pre><code class="q">q).Q.view[]
q)select from t / once again gets everything!
date       ti       p
-----------------------
2015.01.01 09:30:00 101
2015.01.01 09:31:00 102
2015.01.02 09:30:00 100
2015.01.02 09:31:00 100
2015.01.03 09:30:00 103
2015.01.03 09:31:00 104
</code></pre>

<p>You can use the partition value variable <code>.Q.pv</code> in the argument to <code>.Q.view</code>.</p>
<pre><code class="q">q).Q.view[]
q).Q.pv
2015.01.01 2015.01.02 2015.01.03
q).Q.view -2#.Q.pv
q)select from t / &lt;- normally dangerous
date       ti       p
-----------------------
2015.01.02 09:30:00 100
2015.01.02 09:31:00 100
2015.01.03 09:30:00 103
2015.01.03 09:31:00 104
</code></pre>

<h2 id="146-kdb-database">14.6 Kdb Database<a class="headerlink" href="14_Introduction_to_Kdb+.1#146-kdb-database" title="Permanent link">&para;</a></h2>
<p>Many kdb+ newcomers find the notion of a kdb+ database shrouded in mystery. In this section, we answer common qbie questions.</p>
<ul>
<li>What is a kdb+ database?</li>
<li>How is it different from an RDBMS?</li>
<li>How do I create a kdb+ database?</li>
<li>How do I startup a kdb+ database?</li>
<li>What happens at startup?</li>
</ul>
<h3 id="1461-comparing-kdb-to-an-rdbms">14.6.1 Comparing kdb+ to an RDBMS<a class="headerlink" href="14_Introduction_to_Kdb+.1#1461-comparing-kdb-to-an-rdbms" title="Permanent link">&para;</a></h3>
<p>While q-sql makes certain aspects of a kdb+ database seem familiar to a SQL programmer, the two are quite different under the covers. Folks coming into the world of q and kdb+ from a traditional RDBMS environment may feel as if they have entered the Matrix after taking the red pill from Morpheus. The fundamental differences are:</p>
<ol>
<li>
<p>Kdb+ is based on lists, which are ordered collections allowing duplicates, whereas SQL is based on sets, which are unordered collections of distinct elements.</p>
</li>
<li>
<p>Kdb+ stores data as contiguous items in column lists, whereas an RDBMS stores data as fields within non-contiguous rows. Neo in kdb+ says, “There are no rows.”</p>
</li>
<li>
<p>Kdb+ table operations are vector operations on columns, whereas SQL operates on individual fields and rows.</p>
</li>
</ol>
<p>We summarize the major differences between an RDBMS and kdb+ in the following chart.</p>
<table>
<thead>
<tr>
<th></th>
<th>Traditional RDBMS</th>
<th>Kdb+ Database</th>
</tr>
</thead>
<tbody>
<tr>
<td>Table Creation</td>
<td>Tables defined declaratively using DDL and created on disk.</td>
<td>Tables created functionally in the q language.</td>
</tr>
<tr>
<td>Data Persistence</td>
<td>Tables and related metadata held in an opaque repository. Tables are stored by row.</td>
<td>Serialized q entities stored in the O/S file system. No separate table metadata. Tables are stored by column.</td>
</tr>
<tr>
<td>Data Access</td>
<td>Access to stored information is via DDL for metadata and SQL for data. Must retrieve via a query into program.</td>
<td>Data directly accessible in q. q-sql provides query forms for table manipulation.</td>
</tr>
<tr>
<td>Memory Residency</td>
<td>Tables reside on disk; query result sets reside in program memory.</td>
<td>Tables live in memory but can be persisted to disk. Column subsets are page faulted into memory for mapped tables.</td>
</tr>
<tr>
<td>Data Format</td>
<td>Based on sets, which are unordered collection of distinct items. Data is stored in fields within rows, which are not contiguous.</td>
<td>Based on lists, which are ordered collections allowing duplicates. Data is stored as contiguous items in column lists.</td>
</tr>
<tr>
<td>Data Modification</td>
<td>Persisted table modifiable via SQL (<code>INSERT</code>, <code>UPDATE</code>, etc.)</td>
<td>Memory resident tables modifiable via q and q-sql. Persisted table modifiable only with append (<code>upsert</code>)</td>
</tr>
<tr>
<td>Data Programming</td>
<td>SQL is declarative relational. Programs, called stored procedures, written in proprietary procedural language.</td>
<td>Programs written in integrated vector functional language q. Tables are first class entities in q.</td>
</tr>
<tr>
<td>Transactions</td>
<td>Support for transactions via <code>COMMIT</code> and <code>ROLLBACK</code>.</td>
<td>No built-in transaction support.</td>
</tr>
</tbody>
</table>
<h3 id="1462-the-physical-layout-of-a-kdb-database">14.6.2 The Physical Layout of a kdb+ Database<a class="headerlink" href="14_Introduction_to_Kdb+.1#1462-the-physical-layout-of-a-kdb-database" title="Permanent link">&para;</a></h3>
<p>Here is a Zen koan: What is a kdb+ database? At the most basic level, a kdb+ database is a file system directory (and sub directories) holding q entities. This directory is the <em>root</em> of the database. All constituents of the database are simply q entities saved in files. Database entities either reside at some level under the root or are pointed to from <code>par.txt</code> under the root.</p>
<p>We describe the various kdb+ database components in this section and show examples in the following section. In our descriptions we use <code>/db</code> as our root, but this is arbitrary.</p>
<h3 id="14621-the-sym-file">14.6.2.1 The sym File<a class="headerlink" href="14_Introduction_to_Kdb+.1#14621-the-sym-file" title="Permanent link">&para;</a></h3>
<p>The sym file is an optional serialized q data file containing a list of unique symbols used as the domain for symbol enumeration. Placing the sym file in the root guarantees that it will be loaded into memory at q startup.</p>
<pre><code>/db
    sym …
</code></pre>

<p>There is no strict requirement that there be only one enumeration domain, but conventionally all symbol columns from all tables are enumerated over a single domain sym. The <code>.Q</code> utilities that handle symbol enumeration assume this. If you choose to have multiple enumeration domains, be aware that symbols in the resulting enumerated values will act as expected under <code>=</code> but not with <code>~</code> since they have different types. You can resolve the enumerations with <code>value</code> if this is a problem.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Pay very careful attention to the sym file, as it is a single point of failure. Corrupting or losing it will result in all your symbol columns being irresolvable. Good practice is to use conditional enumeration – e.g., <code>`:/db/sym?</code> – when you enumerate symbols manually or use <code>.Q</code> utilities that do this for you. Always back up your database before operating on the sym file.</p>
</div>
<p>The sym file will not normally be a choke point when loading historical data from an external source into a kdb+ because conditional enumeration (and the <code>.Q</code> utilities) use file locking to mediate concurrent updates. Alternately, if the symbol domain is known in advance, you can load the sym list into memory and use non-conditional enumeration – i.e., <code>`sym$</code>. For example, one approach is to create a preprocessing utility in Perl to extract all symbols from the source data, import this as a list in q and place the distinct items in sym. Then create the historical partitions running concurrent processes that use unconditional enumerations. Be mindful that unconditional enumeration fails for a symbol not in the domain.</p>
<h3 id="14622-other-serialized-files-in-root">14.6.2.2 Other Serialized Files in Root<a class="headerlink" href="14_Introduction_to_Kdb+.1#14622-other-serialized-files-in-root" title="Permanent link">&para;</a></h3>
<p>While it is seldom done in practice (perhaps because few kdb+ programmers are aware of the possibility), it is possible to place any serialized q entity into the root and have it loaded into an eponymous file. This can be a more efficient than using a script to initialize variables in the workspace.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you use this, don’t go overboard. Also, it might break <code>.Q.en</code>.</p>
</div>
<pre><code>/db
    [sym]
    var1
    var2
    …
</code></pre>

<p>One type of serialized file that can be initialized in this fashion is a reference table (or keyed table) of modest size (up to millions of rows). Such a table will be loaded into memory in its entirety, so lookups or joins on it will be quite fast.</p>
<p>It is possible to (re)load the entire state of the root context automatically by serializing that directory and loading it in this fashion.</p>
<h3 id="14623-scripts">14.6.2.3 Scripts<a class="headerlink" href="14_Introduction_to_Kdb+.1#14623-scripts" title="Permanent link">&para;</a></h3>
<p>A script in the root can hold arbitrary q code that will be loaded upon startup. In particular, functions defined in such a script can be viewed as stored procedures for the database. While it is possible to have multiple q scripts in the root, you probably want precise control over the order in which the scripts are executed. Good practice is to keep in the root one startup script that loads scripts residing in libraries elsewhere.</p>
<pre><code>/db
    …
    init.q
</code></pre>

<h3 id="14624-splayed-tables">14.6.2.4 Splayed Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#14624-splayed-tables" title="Permanent link">&para;</a></h3>
<p>Reference tables of intermediate size (up to tens of millions of rows) can be splayed under the root. Splayed table directories must be immediately under the root.</p>
<pre><code>/db
    [sym]
    …
    /splay1
    /splay2
    …
</code></pre>

<p>Because splayed tables are mapped and columns are page-faulted into memory as needed, no more than a few columns will be simultaneously resident in the workspace. Assuming that the server has adequate memory available to kdb+, q should expect to find recently accessed columns cached by the OS. In this scenario, performance of lookups against splayed tables can be close to that of in-memory tables.</p>
<h3 id="14625-partitioned-tables">14.6.2.5 Partitioned Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#14625-partitioned-tables" title="Permanent link">&para;</a></h3>
<p>The partition directories of non-segmented tables must be immediately under the root. Every partition directory contains a subdirectory for each table sharing the partition; in each subdirectory is the splayed slice for that table's partition value. For example, for daily partitioned trades and quotes, a day’s directory would contain a splayed directory for that day’s trades and another splayed directory for that day’s quotes.</p>
<pre><code>/db
    [sym]
    …
    /part1
        /trade
        /quote
    /part2
        /trade
        /quote …
</code></pre>

<p>There need not be a directory for every partition value but the partition directories must have a uniform structure. That is, a partition value having <strong>any</strong> entry must contain splayed directories for <strong>all</strong> tables in the partition. Splay an empty schema for a table having no records for a partition value.</p>
<h3 id="14626-segmented-tables">14.6.2.6 Segmented Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#14626-segmented-tables" title="Permanent link">&para;</a></h3>
<p>In contrast to normal partitioned tables (i.e., non-segmented tables) in which all records live under the root, no records of a segmented table can reside under the root. Instead, the root contains a text file <code>par.txt</code> having one entry per line. Each entry represents an OS path for a segment directory containing the data in that segment; symlinks are permissible.</p>
<p>Each segment directory contains partition directories whose structure is completely analogous to that of a regular partitioned table. There is one directory per partition value and beneath that, one sub-directory per table. Note that depending on the nature of the segmentation, multiple segment directories may contain directories for the same partition value. The previous restriction about consistency across partition directories applies to segments.</p>
<pre><code>/db
    [sym]
    …
    par.txt
    …
== drive 1 =============
/seg1
    /part1
    /part2
    …
== drive 2 =============
/seg2
    /parta
    /partb
    …
== … =============
</code></pre>

<h3 id="1463-creating-and-populating-a-kdb-database">14.6.3 Creating and Populating a kdb+ Database<a class="headerlink" href="14_Introduction_to_Kdb+.1#1463-creating-and-populating-a-kdb-database" title="Permanent link">&para;</a></h3>
<p>Here we demonstrate how to create and populate various kdb+ database configurations. Although the examples are simplistic, they cover most common situations.</p>
<p>There are no wizards for laying out and populating a kdb+ database. Instead, you must write each component in the correct form to the correct location. There are utilities to help with the process but it is your responsibility to ensure that everything is valid. Improperly structured directories or incorrectly written data files will generate run-time errors the first time q code attempts to access them.</p>
<p>Once you have created a kdb+ database, start a q process pointing at the root directory of the database to attach it to the session. Alternately, in a running q instance you can issue <code>\l</code> on the root directory.</p>
<h3 id="14631-what-happens-at-startup">14.6.3.1 What Happens at Startup?<a class="headerlink" href="14_Introduction_to_Kdb+.1#14631-what-happens-at-startup" title="Permanent link">&para;</a></h3>
<p>This question has a deceptively simple answer. When you point q at a directory or file, it applies a single rule:</p>
<p>Whatever it recognizes as its own, it does.</p>
<p>Thus, a serialized q entity is loaded; a splayed, partitioned or segmented table is mapped; a script is executed.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Almost anything that q does not recognize causes it to abort that portion of startup. In particular, if q discovers foreign or undecipherable files in splayed, partitioned or segmented directories, it will not map the tables contained there. Even unexpected hidden files (e.g., those written by the Mac OS Finder) will abort the map.</p>
</div>
<p>When you point q startup at a directory, that directory becomes the root directory for the kdb+ database and also the current working directory for the OS. We shall refer to this scenario as <em>kdb+ startup</em> to distinguish it from an arbitrary q session. We shall cover the items that Kdb+ startup finds in the order that it handles them.</p>
<ol>
<li>
<p>Serialized q entities</p>
</li>
<li>
<p>Splayed tables</p>
</li>
<li>
<p>Partitioned or segmented tables</p>
</li>
<li>
<p>Scripts</p>
</li>
</ol>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>File handles that are not fully qualified – i.e., relative paths – are interpreted relative to the q home directory.</p>
</div>
<h3 id="14632-serialized-q-entities">14.6.3.2 Serialized q Entities<a class="headerlink" href="14_Introduction_to_Kdb+.1#14632-serialized-q-entities" title="Permanent link">&para;</a></h3>
<p>When kdb+ startup recognizes a serialized q data file, it loads that data into an eponymous variable. The canonical example is the sym file in the root, containing the serialized list of (unique) symbols in the enumeration domain for (all) symbol columns. Multiple serialized entities are loaded in the order in which the OS file system lists them.</p>
<p>In our first example, we manually write out a sym file, exit q and then start kdb+ pointing at the root.</p>
<pre><code class="q">q)`:/db/sym set `a`b`c`z`x`y
`:/db/sym
q)\\
</code></pre>

<pre><code class="bash">$q /db
</code></pre>

<pre><code class="q">q)sym
`a`b`c`z`x`y
</code></pre>

<p>Starting with a fresh <code>/db</code>, we place a defined “constant,” a utility function and a serialized keyed table in the root.</p>
<pre><code class="q">q) `:/db/LIFE set 42
`:/db/LIFE
q)`:/db/f set {x*y}
`:/db/f
q)`:/db/lookup set ([s:`a`b`c] v:1 2 3)
`:/db/lookup
q)\\
</code></pre>

<pre><code class="bash">$q /db
</code></pre>

<pre><code class="q">q)LIFE
_
q)f
_
q)lookup
_
</code></pre>

<p>As of this writing (Sep 2015), q will not look for serialized data in directories other than the root. Nor will it automatically load serialized data whose file names have extensions. However, you can load such data files manually using <code>\l</code> or <code>get</code>.</p>
<h3 id="14633-splayed-tables">14.6.3.3 Splayed Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#14633-splayed-tables" title="Permanent link">&para;</a></h3>
<p>When kdb+ startup finds a subdirectory immediately beneath the root that it recognizes as a splayed table, it maps the table into memory. All symbol columns must be enumerated for a table to be splayed. Ensure that the sym file is in the root directory if you do not use a built-in utility.</p>
<p>Starting with a fresh <code>/db</code>, we splay two tables under the root. The first does not have symbol columns; the second does.</p>
<pre><code class="q">q)`:/db/tref/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)`:/db/cust/ set .Q.en[`:/db;] ([] sym:`ibm`msft`goog; name:`oracle`microsoft`google)
_
q)\\
</code></pre>

<pre><code class="bash">$q /db
</code></pre>

<pre><code class="q">q)select from tref
c1 c2
_
q)select from cust
_
</code></pre>

<h3 id="14634-partitioned-tables">14.6.3.4 Partitioned Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#14634-partitioned-tables" title="Permanent link">&para;</a></h3>
<p>If kdb+ startup finds subdirectories immediately beneath the root whose names constitute valid partition values, it examines them for splayed tables comprising partition slices. Valid partitioned tables are mapped. The presence of partitioned tables is independent of the presence of (plain) splayed tables. Partitioned tables and segmented tables are mutually exclusive.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All symbol columns in every partition slice must be enumerated, customarily over a file sym in the root. Ensure that the sym file is in the root directory if you do not use the built-in utilities.</p>
</div>
<p>We recreate the previous example in which multiple tables share a daily partition in a fresh <code>/db</code>.</p>
<pre><code class="q">q)`:/db/2015.01.01/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101 33f)
_
q)`:/db/2015.01.02/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101.5 33.5)
_
q)`:/db/2015.01.01/q/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; b:100.75 32.75; a:101.25 33.25f)
_
q)`:/db/2015.01.02/q/ set .Q.en[`:/db;] ([] ti:09:30:00 09:30:00; sym:`ibm`msft; b:101.25 33.25; a:101.75 33.75)
_
q)\\
</code></pre>

<pre><code class="bash">$ q /db
</code></pre>

<pre><code class="q">q)\l /db
q
q)select from t where date within 2015.01.01 2015.01.02
-
q)select from q where date within 2015.01.01 2015.01.02
_
</code></pre>

<h3 id="14635-segmented-tables">14.6.3.5 Segmented Tables<a class="headerlink" href="14_Introduction_to_Kdb+.1#14635-segmented-tables" title="Permanent link">&para;</a></h3>
<p>When kdb+ startup finds a <code>par.txt</code> file in the root, it interprets each line as a segment location and it examines the locations for valid segments of partitioned tables. Valid tables are mapped.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Ensure that the segment directories are not located under the root; otherwise you will relive the table scene in the first <em>Alien</em> movie.</p>
</div>
<p>The presence of segmented tables is independent of the presence of plain splayed tables. Segmented tables and partitioned tables are mutually exclusive. All symbol columns in every segment must be enumerated. Ensure that the (common) sym file is in the root directory.</p>
<p>We recreate the previous example from <a href="14_Introduction_to_Kdb+.1#144-segmented-tables">§14.4</a> in which multiple tables share segmentation by symbol range. In fresh directories <code>/am</code>, <code>/nz</code> and <code>/db</code>,</p>
<pre><code class="q">q)extr:{[t;r] select from t where (`$1#'string sym) within r}
q)t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`t; p:101 17f)
q)q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`ibm`t`ibm; b:100.75 16.9 100.8;a:101.25 17.1 101.1)

q)`:/am/2015.01.01/t/ set extr[t;`a`m]
_
q)`:/nz/2015.01.01/t/ set extr[t;`n`z]
_
q)`:/am/2015.01.01/q/ set extr[q;`a`m]
_
q)`:/nz/2015.01.01/q/ set extr[q;`n`z]
_
q)t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`t`ibm; p:17.1 100.9)
q)q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`t`ibm`t;b:17 100.7 17.1;a:17.2 101.25 17.25)

q)`:/am/2015.01.02/t/ set extr[t;`a`m]
_
q)`:/nz/2015.01.02/t/ set extr[t;`n`z]
_
q)`:/am/2015.01.02/q/ set extr[q;`a`m]
_
q)`:/nz/2015.01.02/q/ set extr[q;`n`z]
_
q)`:/db/par.txt 0: (&quot;/am&quot;; &quot;/nz&quot;)
`:/db/par.txt
q)\\
</code></pre>

<pre><code class="bash">$q
</code></pre>

<pre><code class="q">q)\l /db
q)select from t where date within 2015.01.01 2015.01.02
_
q)select from q where date within 2015.01.01 2015.01.02
_
</code></pre>

<h3 id="14636-scripts">14.6.3.6 Scripts<a class="headerlink" href="14_Introduction_to_Kdb+.1#14636-scripts" title="Permanent link">&para;</a></h3>
<p>Files with extension <code>.q</code> are interpreted as q scripts; those with extension <code>.k</code> as k scripts. Scripts found in the root are loaded and executed in alphabetical order. You will probably want better control over the order of execution, so it is best to have in the root a single script that loads other scripts in the desired sequence.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An invalid expression in a script causes the entire script load to abort. Locating the invalid entry can be non-trivial since by default console display is suppressed during load. Judicious use of <code>0N!</code> can be helpful. Sometimes using binary search using block comments is an effective approach to locating the offending line. Bottom line: keep scripts short!</p>
</div>
<p>In our first example, we initialize the workspace using a startup script <code>/db/init.q</code> that we create from q (because we can). You could do it in any text editor.</p>
<pre><code class="q">q)`:/db/init.q 0: (&quot;LIFE:42&quot;;&quot;f:{x*y}&quot;;&quot;lookup:([s:`a`b`c] v:1 2 3)&quot;)
`:/db/init.q
q)\\
$q /db
q)LIFE
_
q)f
_
q)lookup
_
</code></pre>

<p>Since scripts are loaded as the last step in kdb+ startup, any loaded script can rely on startup, serialized variables and mapped tables bring present. For example, in a fresh <code>/db</code> we create a splayed table and a startup script from within q and then run the script at startup.</p>
<pre><code class="q">q)`:/db/cust/ set .Q.en[`:/db;] ([] sym:`ibm`msft`goog;name:`oracle`microsoft`google)
_
q)`:/db/init.q 0: (&quot;sym&quot;; &quot;show select from cust&quot;)
_
q)\\
</code></pre>

<pre><code class="bash">$q /db
</code></pre>

<pre><code class="q">`ibm`msft`goog`oracle`microsoft`google
sym  name
--------------
ibm  oracle
msft microsoft
goog google
q)
</code></pre>

<p>Now we demonstrate a script that loads other scripts. Start with a fresh <code>/db</code>. We write out a script having a library function (you could do it in a text editor) and then load that script from <code>init.q</code> at startup.</p>
<pre><code class="q">q)`:/scripts/expr.q 0: enlist &quot;.jab.lib.expr.subst:{x@y}&quot;
_
q)`:/db/init.q 0: enlist &quot;\\l /scripts/expr.q&quot;
_
q)\\
</code></pre>

<pre><code class="bash">$q /db
</code></pre>

<pre><code class="q">q).jab.lib.expr.subst
{x@y}
</code></pre>

<h2 id="147-putting-it-all-together">14.7 Putting It All Together<a class="headerlink" href="14_Introduction_to_Kdb+.1#147-putting-it-all-together" title="Permanent link">&para;</a></h2>
<p>In this section, we combine the various constituents of a kdb+ database demonstrated in the previous sections to give two archetypal examples. The first has partitioned tables; the second has segmented tables.</p>
<h3 id="1471-partitioned-database">14.7.1 Partitioned Database<a class="headerlink" href="14_Introduction_to_Kdb+.1#1471-partitioned-database" title="Permanent link">&para;</a></h3>
<p>To construct our partitioned database, we combine the steps in previous sections to obtain the following meta-script. (We assume that the scripts in <code>/lib</code> already exist.)</p>
<pre><code class="q">/ create serialized variables
`:/db/LIFE set 42
`:/db/f set {x*y}
`:/db/lookup set ([s:`a`b`c] v:1 2 3)

/ create splayed tables
`:/db/tref/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
`:/db/cust/ set .Q.en[`:/db;] ([] sym:`ibm`msft`goog; name:`:/db/sym?`oracle`microsoft`google)

/create partitioned tables
`:/db/2015.01.01/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101 33f)
`:/db/2015.01.02/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101.5 33.5)
`:/db/2015.01.01/q/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; b:100.75 32.75; a:101.25 33.25)
`:/db/2015.01.02/q/ set .Q.en[`:/db;] ([] ti:09:30:00 09:30:00; sym:`ibm`msft; b:101.25 33.25; a:101.75 33.75)

/ create load script
`:/db/init.q 0: (&quot;TheUniverse:42&quot;;&quot;\\l /lib/math.q&quot;;
 &quot;\\l /lib/expr.q&quot;)
</code></pre>

<p>Now execute this script to create the database. The resulting partitioned database has the following layout.</p>
<pre><code>/db
    sym
    LIFE
    F
    Lookup
    /tref
        .d
        c1
        c2
    /cust
        .d
        sym
        name
    /2009.01.01
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
    /2009.01.02
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
    init.q
</code></pre>

<h3 id="1472-segmented-database">14.7.2 Segmented Database<a class="headerlink" href="14_Introduction_to_Kdb+.1#1472-segmented-database" title="Permanent link">&para;</a></h3>
<p>To construct a segmented database, we combine previous steps to obtain the following meta-script. (We again assume that the scripts in <code>/lib</code> already exist.)</p>
<pre><code class="q">/ create serialized variables
`:/db/LIFE set 42
`:/db/f set {x*y}
`:/db/lookup set ([s:`a`b`c] v:1 2 3)

/ create splayed tables
`:/db/tref/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
`:/db/cust/ set .Q.en[`:/db;] ([] sym:`ibm`msft`goog; name:`oracle`microsoft`google)

/ create segmented tables
extr:{[t;r] select from t where (`$1#'string sym) within r}
t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`t; p:101 17f)
q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`ibm`t`ibm; b:100.75 16.9 100.8; a:101.25 17.1 101.1)
`:/am/2015.01.01/t/ set extr[t;`a`m]
`:/nz/2015.01.01/t/ set extr[t;`n`z]
`:/am/2015.01.01/q/ set extr[q;`a`m]
`:/nz/20015.01.01/q/ set extr[q;`n`z]
t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`t`ibm; p:17.1 100.9)
q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`t`ibm`t; b:17 100.7 17.1;a:17.2 101.25 17.25)
`:/am/2015.01.02/t/ set extr[t;`a`m]
`:/nz/2015.01.02/t/ set extr[t;`n`z]
`:/am/2015.01.02/q/ set extr[q;`a`m]
`:/nz/2015.01.02/q/ set extr[q;`n`z]

`:/db/par.txt 0: (&quot;/am&quot;; &quot;/nz&quot;)

/ create load script
`:/db/init.q 0: (&quot;TheUniverse:6*7&quot;; &quot;\\l /lib/math.q&quot;; &quot;\\l /lib/expr.q&quot;)
</code></pre>

<p>Now execute this script to create the database. The resulting partitioned database has the following layout.</p>
<pre><code>/db
    sym
    LIFE
    F
    Lookup
    /tref
        .d
        c1
        c2
    /cust
        .d
        sym
        name
    par.txt
    init.q
== drive 1 ==
/am
    /2009.01.01
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
    /2009.01.02
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
== drive 2 ==
/nz
    /2009.01.01
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
    /2009.01.02
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
</code></pre>

<h2 id="148-theres-no-place-like-qhome">14.8 There's No Place Like QHOME<a class="headerlink" href="14_Introduction_to_Kdb+.1#148-theres-no-place-like-qhome" title="Permanent link">&para;</a></h2>
<p>We discuss how kdb+ interacts with the OS environment when it looks for files.</p>
<h3 id="1481-the-environment-variables">14.8.1 The Environment Variables<a class="headerlink" href="14_Introduction_to_Kdb+.1#1481-the-environment-variables" title="Permanent link">&para;</a></h3>
<p>Three environment variables <code>QHOME</code>, <code>QLIC</code> and <code>QINIT</code> are used by kdb+ at startup.</p>
<p>The environment variable <code>QHOME</code> specifies the directory where kdb+ expects to find the bootstrap file <code>q.k</code>. By default, it also looks there for the license file <code>k4.lic</code>. If <code>QHOME</code> is not defined, kdb+ falls back to <code>$HOME/q</code> for Unix-based systems and <code>c:\q</code> for Windows.</p>
<p>The environment variable <code>QLIC</code> overrides the default location for the license file. If <code>QLIC</code> is not defined, kdb+ falls back to <code>QHOME</code> (or its fallback).</p>
<p>The environment variable <code>QINIT</code> specifies the name of the file that is executed immediately after the load of <code>q.k</code>. If <code>QINIT</code> is not defined, kdb+ attempts to load the file <code>q.q</code> from <code>QHOME</code>. If <code>QHOME</code> is not defined or <code>q.q</code> is not found, no error is reported.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The file in <code>QINIT</code> is executed in the root context (i.e., <code>\d</code>).</p>
</div>
<h3 id="1482-q-in-da-hood">14.8.2 q in da hood<a class="headerlink" href="14_Introduction_to_Kdb+.1#1482-q-in-da-hood" title="Permanent link">&para;</a></h3>
<p>Upon startup, the current directory is the directory from which the q session was started.</p>
<p>After startup, an easy way to see where in the file system the q executable resides is to use a function such as the niladic whereami below. Recall that the command <code>\cd</code> acts like the OS <code>cd</code> command by returning the current working directory.</p>
<pre><code class="q">whereami:{-1 &quot;cd ~ &quot;,system &quot;cd&quot;;}
</code></pre>

<p>Loading a script that resides elsewhere does not in itself change the current directory; of course, if that script executes a <code>\cd</code> then the current directory may change. In particular, the current directory is not temporarily changed to the location of the target script.</p>
<p>Loading a database, either as part of the startup invocation or via a <code>\l</code> command, changes the current directory to the database root. All subsequent relative access is based from there. This is important when starting q with <code>-u</code> as it determines the file hierarchy visibility.</p>
<p>When asked to load a file whose name is not fully qualified, q first searches the current directory. If the file is not found, it then searches <code>QHOME</code> if it is defined and <code>$HOME</code> otherwise.</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="13_Commands_and_System_Variables.1" title="13. Commands and System Variables" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                13. Commands and System Variables
              </span>
            </div>
          </a>
        
        
          <a href="A_Built-in_Functions.1" title="Appendix A. Built-in Functions" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Appendix A. Built-in Functions
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            ©2015 Jeffry A. Borror / q4m LLC. Kx® and kdb+ are registered trademarks of Kx Systems, Inc., a subsidiary of First Derivatives plc.
          </div>
        
        powered by
        <a href="http://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="assets/javascripts/application.b438e6c5.js"></script>
      
      <script>app.initialize({version:"0.17.3",url:{base:".."}})</script>
      
        <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
      
        <script src="https://tracker.mrpfd.com/tracker.js"></script>
      
        <script src="http://code.kx.com/scripts/googleanalytics.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
        <script src="https://use.fontawesome.com/3dbf29ed12.js"></script>
      
        <script src="http://code.kx.com/scripts/prism.js"></script>
      
    
    
      
    
  </body>
</html>